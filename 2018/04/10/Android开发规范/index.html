<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android,">










<meta name="description" content="说明本手册以开发者为中心视角分为Java语言规范，Android资源文件命名与使用，Android基本组件，UI与布局，进程、线程与消息通信，文件与数据库，Bitmap、Drawable与动画，安全，其他等就大部分，根据约束力强弱，规约依次分为强制、推荐、参考三大类：  【强制】必须遵守，违反本约定或将会引起严重的后果； 【推荐】尽量遵守，长期遵守有助于系统稳定性和合作效率的提升； 【参考】充分理">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开发规范">
<meta property="og:url" content="http://yoursite.com/2018/04/10/Android开发规范/index.html">
<meta property="og:site_name" content="老易的博客">
<meta property="og:description" content="说明本手册以开发者为中心视角分为Java语言规范，Android资源文件命名与使用，Android基本组件，UI与布局，进程、线程与消息通信，文件与数据库，Bitmap、Drawable与动画，安全，其他等就大部分，根据约束力强弱，规约依次分为强制、推荐、参考三大类：  【强制】必须遵守，违反本约定或将会引起严重的后果； 【推荐】尽量遵守，长期遵守有助于系统稳定性和合作效率的提升； 【参考】充分理">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-04-10T10:21:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android开发规范">
<meta name="twitter:description" content="说明本手册以开发者为中心视角分为Java语言规范，Android资源文件命名与使用，Android基本组件，UI与布局，进程、线程与消息通信，文件与数据库，Bitmap、Drawable与动画，安全，其他等就大部分，根据约束力强弱，规约依次分为强制、推荐、参考三大类：  【强制】必须遵守，违反本约定或将会引起严重的后果； 【推荐】尽量遵守，长期遵守有助于系统稳定性和合作效率的提升； 【参考】充分理">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/10/Android开发规范/">





  <title>Android开发规范 | 老易的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老易的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">大口吃瓜 快意飞马</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/10/Android开发规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老易的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android开发规范</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T18:16:36+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/10/Android开发规范/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2018/04/10/Android开发规范/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本手册以开发者为中心视角分为Java语言规范，Android资源文件命名与使用，Android基本组件，UI与布局，进程、线程与消息通信，文件与数据库，Bitmap、Drawable与动画，安全，其他等就大部分，根据约束力强弱，规约依次分为强制、推荐、参考三大类：</p>
<ul>
<li><code>【强制】</code>必须遵守，违反本约定或将会引起严重的后果；</li>
<li><code>【推荐】</code>尽量遵守，长期遵守有助于系统稳定性和合作效率的提升；</li>
<li><code>【参考】</code>充分理解，技术意识的引导，是个人学习、团队沟通、项目合作的方向</li>
</ul>
<p>对于文档中的相关拓展信息，<code>说明</code>对内容作了适当扩展和解释；<code>正例</code>提倡具体的编码和实现方式；<code>反例</code>说明需要提防的雷区，以及错误案例。</p>
<h2 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><ul>
<li><code>【强制】</code>代码中的命名均不能以下划线或美元符号开始，也不能以下划线与美元符号结束。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">_name/__name/$name/name_/name$/name_</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</li>
</ul>
<blockquote>
<p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免其一。注意，及时纯拼音命名方式也要避免采用</p>
</blockquote>
<ul>
<li><code>【强制】</code>类名使用UpperCamelCase风格</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">MarcoPolo/UserDO/XmlService/</span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line">macroPolo/UserDo/XMLService/</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">localValue/getHttpMessage()/inputUserId</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>常量命名全部大写，单词之间用下划线隔开，力求予以表达完整清楚，不要嫌名字长</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">MAX_STOCK_COUNT</span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line">MAX_COUNT</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类名开始，以Test结尾。</li>
<li><code>【强制】</code>类型与中括号紧挨相连来定义数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：定义整形数组</span></span><br><span class="line"><span class="keyword">int</span>[] arrayDemo</span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line">String args[]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>POJO类中布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列化错误。</li>
<li><code>【强制】</code>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：应用工具类包名为com.partner.example.util，类名为MessageUtils（此规则参考spring的框架结构）</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>杜绝完全不规范的缩写，避免望文不知义。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成condi，此类随意缩写严重降低了代码的可阅读性。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>为了达到代码自解释的目标，任何自定义变成元素在命名时，使用尽量完整的单词组合来表达其意。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正例：从远程仓库拉取代码的类命名为PullCodeFromRemoteRepository。</span><br><span class="line">反例：变量<span class="keyword">int</span> a；的随意命名方式。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。</li>
</ul>
<blockquote>
<p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFactory</span></span>; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginProxy</span></span>; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceObserver</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>接口类中的方法和属性不要加任何修饰符号（public也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="comment">//接口方法签名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="comment">//接口基础常量</span></span><br><span class="line">String COMPANY = “partner”；</span><br><span class="line"></span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="comment">//接口方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">( )</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。</p>
</blockquote>
<ul>
<li><code>【推荐】</code>形容能力的接口名称，去对应的形容词为接口名（通常是-able的形式）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">AbstractTranslator实现Translatable</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【参考】</code>枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。</li>
</ul>
<blockquote>
<p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS/UNKNOWN_REASON</span><br></pre></td></tr></table></figure>
<h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><ul>
<li><code>【强制】</code>不允许任何魔法值（即未预先定义的常量）直接出现在代码中。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">String key = “Id#partner_”+ tradeId; cache.put(key,value);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>long或者Long初始赋值时，使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。</li>
</ul>
<blockquote>
<p>说明：Long a = 2l；写的是数字21还是Long型的2？</p>
</blockquote>
<ul>
<li><code>【推荐】</code>不要使用一个常量类维护所有常量，按常量功能进行分类，分开维护。</li>
</ul>
<blockquote>
<p>说明：大而全的常量类，飞的使用查找功能才能定位到修改的常量，不利于理解和维护。</p>
</blockquote>
<ul>
<li><code>【推荐】</code>常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。<ul>
<li>跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下</li>
<li>应用内共享常量：防止在一方库中，通常是子模块中的constant目录下</li>
<li>子工程内部共享常量：即在当前子工程的constant目录下。</li>
<li>包内共享常量：即在当前包下单独的constant目录下。</li>
<li>类内共享常量：直接在类内部private static final定义。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：易懂变量也要统一定义成应用内共享常量，两位工程师在两个类中分别定义了表示“是”的变量：</span></span><br><span class="line"><span class="comment">//类A中：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YES = “yes”;</span><br><span class="line"><span class="comment">//类B中：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YES = “y”;</span><br><span class="line">A.YES.equals(B.YES)，预期是<span class="keyword">true</span>，但时机返回为<span class="keyword">false</span>，导致线上问题。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>如果变量值尽在一个固定范围内变化用enum类型来定义</li>
</ul>
<blockquote>
<p>说明：如果存在名称之外的延伸属性使用enum类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> SeasonEnum&#123;</span><br><span class="line">        SPRING(<span class="number">1</span>)，SUMMER(<span class="number">2</span>)，AUTUMN(<span class="number">3</span>)，WINTER(<span class="number">4</span>);</span><br><span class="line">        Int seq;</span><br><span class="line">        SeasonEnum(<span class="keyword">int</span> seq)&#123;</span><br><span class="line">            <span class="keyword">this</span>.seq = seq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><ul>
<li><code>【强制】</code>大括号的使用约定。如果是大括号内为空，则简洁地写成{ }即可，不需要换行；如果是非空代码块则：<ul>
<li>左大括号前不换行；</li>
<li>做大括号后换行；</li>
<li>右大括号前换行；</li>
<li>右大括号后还有else等代码则不换行；表示终止的右大括号必须换行。</li>
</ul>
</li>
<li><code>【强制】</code>左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：<span class="keyword">if</span>(空格a == b空格)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>if/for/while/switch/do等保留字与括号之间都必须加空格。</li>
<li><code>【强制】</code>任何二目、三目运算符的左右两边都需要加一个空格。</li>
</ul>
<blockquote>
<p>说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</p>
</blockquote>
<ul>
<li><code>【强制】</code>采用4个空格缩进，禁止使用tab字符、</li>
</ul>
<blockquote>
<p>说明：如果是用tab缩进，必须设置1个tab为4个空格。Android Studio设置tab为4个空格时，请勿勾选Use tab character。</p>
</blockquote>
<ul>
<li><code>【强制】</code>注释的双鞋县与注释内容之间有且仅有一个空格。</li>
<li><code>【强制】</code>单行字符数限制不超过120个，超出需要换行，换行时遵循如下规则：<ul>
<li>第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进，参考示例。</li>
<li>运算符与下文一起换行。</li>
<li>方法调用的点符号与下文一起换行。</li>
<li>方法调用时，多个参数，需要换行时，在逗号后进行。</li>
<li>在括号前不需要换行，见反例。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 超过120个字符的情况下，换行缩进4个空格，点号和方法名一起换行</span></span><br><span class="line">sb.append(“zi”).append(“xin”)...</span><br><span class="line">    .append(“huang”)...</span><br><span class="line">    .append(“huang”)...</span><br><span class="line">    .append(“huang”);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 超过120个字符的情况下，不要在括号前换行</span></span><br><span class="line">sb.append(<span class="string">"zi"</span>).append(<span class="string">"xin"</span>)...append</span><br><span class="line">(<span class="string">"huang"</span>);</span><br><span class="line"><span class="comment">// 参数很多的方法调用可能超过120个字符，不要在逗号前换行</span></span><br><span class="line">method(arg1, args2, args3,…</span><br><span class="line">    , argsx)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>方法参数在定义和传入时，多个参数都好后边必须加空格。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：下例中实参的“a”，后边必须要有一个空格。</span></span><br><span class="line">method(“a”，“b”，“c”)；</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>IDE的text file encoding 设置为UTF-8; IDE文件的换行符使用Unix格式，不要使用Windows格式。</li>
<li><code>【强制】</code>没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。</li>
<li><code>【强制】</code>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。</li>
</ul>
<h3 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h3><ul>
<li><code>【强制】</code>避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析的成本，直接用类名访问即可。</li>
<li><code>【强制】</code>相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。</li>
</ul>
<blockquote>
<p>说明：可变参数必须放置在参数列表的最后。（提议尽量避免使用可变参数编程）</p>
</blockquote>
<ul>
<li><code>【强制】</code>外部正在调用或者第二方库依赖的接口，不允许修改方法名，避免对接口调用方产生影响。结构过时必须加@Deprecated注解，并清晰地说明采用的新接口是什么。</li>
<li><code>【强制】</code>不能使用过时的类或方法</li>
<li><code>【强制】</code>Object的equals方法容易抛空指针异常，应使用常量或者确定有值的对象来调用equals。</li>
</ul>
<blockquote>
<p>说明：推荐使用java.util.Objects#equals（JDK7引入的工具类）</p>
</blockquote>
<ul>
<li><code>【强制】</code>所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。</li>
</ul>
<blockquote>
<p>说明：对于 Integer var = ? 在-128至127范围内的复制，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer只可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。</p>
</blockquote>
<ul>
<li>关于基本数据类型与包装数据类型的使用标准如下：<ul>
<li><code>【强制】</code>所有的POJO类属性必须使用包装数据类型。</li>
<li><code>【强制】</code>RPC方法的返回值和参数必须使用包装数据类型。</li>
<li><code>【推荐】</code>所有的局部变量使用基本数据类型</li>
</ul>
</li>
<li><code>【强制】</code>序列化类新增属性时，不要修改serialVersionUID字段，避免反序列化失败。</li>
<li><code>【强制】</code>构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。</li>
<li><code>【强制】</code>使用当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。</li>
<li><code>【强制】</code>类内方法定义的顺序依次是：共有方法或保护方法&gt;私有方法&gt;getter/setter方法。</li>
</ul>
<blockquote>
<p>说明：共有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低。</p>
</blockquote>
<ul>
<li><code>【强制】</code>setter方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter方法中，不要增加业务逻辑，增加排查问题的难度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line">    <span class="function">Public Integer <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        If(condition)&#123;</span><br><span class="line">            Return <span class="keyword">this</span>.data+<span class="number">100</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Return <span class="keyword">this</span>.data-<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。</li>
</ul>
<blockquote>
<p>说明：反编译出的自己吗文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">    String str = “start”；</span><br><span class="line">    or(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        str = str + “hello”;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>final可以声明类、成员变量、方法以及本地变量，下列情况下使用final关键字：<ul>
<li>不允许被继承的类，如：String类。</li>
<li>不允许被重写的方法。</li>
<li>不允许运行过程中重新赋值的局部变量。</li>
<li>避免上下文重复使用一个变量，使用final描述可以强制重新定义一个变量，方便更好地进行重构。</li>
</ul>
</li>
<li><code>【推荐】</code>慎用Object的clone方法来拷贝对象。</li>
</ul>
<blockquote>
<p>说明：对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现属性对象的拷贝。</p>
</blockquote>
<ul>
<li><p><code>【推荐】</code>类成员与方法访问控制从严：</p>
<ul>
<li>如果不允许外部直接通过new来创建对象，那么构造方法必须是private</li>
<li>工具类不允许有public或default构造方法</li>
<li>类非static成员变量并且与子类共享，必须是protected。</li>
<li>类非static成员变量并且仅在本类使用，必须是private。</li>
<li>类static成员变量如果仅在本类使用，必须是private。</li>
<li>若是stattic成员变量，必须考虑是否为final。</li>
<li>类成员方法只供内部调用，必须是private。</li>
<li>类成员方法只对继承类公开，那么限制为protected。</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。<br>思考：如果是一个private方法，想删除就删除，可是一个public的方法或成员变量，在删除之前如果不find usage一下，很难确定它是否在其他地方有引用。变量和方法像自己的小孩，尽量让它在自己的视线范围内，作用域太大，无限制的到处跑会让人担心。</p>
</blockquote>
<h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><ul>
<li><code>【强制】</code>关于hashCode和equals的处理，遵循如下规则<ul>
<li>只要重写equals，就必须重写hashCode。</li>
<li>因为Set储存的是不重复对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。</li>
<li>如果自定义对象作为Map的键，那么必须重写hashCode和equals。</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：String 重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。</p>
</blockquote>
<ul>
<li><code>【强制】</code>ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException。</li>
</ul>
<blockquote>
<p>说明：subList返回的是ArrayList的内部类SubList，并不是ArrayList，而是ArrayList的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。</p>
</blockquote>
<ul>
<li><p><code>【强制】</code>在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException。</p>
</li>
<li><p><code>【强制】</code>使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的类型完全一样的数组，大小就是list.size()。</p>
</li>
</ul>
<blockquote>
<p>说明：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为[list.size()]的数组元素将被置为null，其他数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。</p>
</blockquote>
<ul>
<li><code>【强制】</code>使用工具类Array.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException。</li>
</ul>
<blockquote>
<p>说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p>
</blockquote>
<ul>
<li><code>【强制】</code>泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用add方法，而&lt;? super T&gt;不能使用get方法，作为借口调用赋值时易出错。</li>
</ul>
<blockquote>
<p>说明：扩展说一下PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt;。</p>
</blockquote>
<ul>
<li><code>【强制】</code>不要在foreach循环里进行remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要Iterator对象加锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">While(iterator.hasNext())&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(“<span class="number">1</span>”);</span><br><span class="line">list.add(“<span class="number">2</span>”)</span><br><span class="line"><span class="keyword">for</span>(String item:list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(“<span class="number">1</span>”.equals(item))&#123;</span><br><span class="line">        list.remove(item);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？</p>
</blockquote>
<ul>
<li><code>【推荐】</code>集合初始化需指定集合的大小</li>
</ul>
<blockquote>
<p>说明：HashMap使用HashMap(int initialCapacity)初始化</p>
</blockquote>
<ul>
<li><code>【推荐】</code>使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历</li>
</ul>
<blockquote>
<p>说明：keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。</p>
</blockquote>
<h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><ul>
<li><code>【推荐】</code>获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</li>
<li><code>【推荐】</code>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</li>
<li><code>【推荐】</code>县城资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li>
</ul>
<blockquote>
<p>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</blockquote>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><ul>
<li><p><code>【推荐】</code>在一个switch块内，每个case要么通过break/return等来中止，要么注释说明程序将继续执行到哪个case为止；在一个switch块内必须包含default语句并且放在最后，即使空代码。</p>
</li>
<li><p><code>【推荐】</code>在if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式。</p>
</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li><code>【推荐】</code>类、类属性、类方法的注释必须使用Javadoc规范，使用<code>/**内容*/</code>格式，不得使用<code>// xxx</code>方式。</li>
</ul>
<p>说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p>
<ul>
<li><code>【推荐】</code>所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</li>
</ul>
<p>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p>
<ul>
<li><code>【推荐】</code>所有的类都必须添加创建者和创建日期。</li>
<li><code>【推荐】</code>方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/<em> </em>/注释，注意与代码对齐。</li>
<li><code>【推荐】</code>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</li>
<li><code>【推荐】</code>谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。</li>
</ul>
<blockquote>
<p>说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p>
</blockquote>
<ul>
<li><code>【推荐】</code>特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<ul>
<li>待办事宜（TODO）:（标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。</li>
</ul>
</li>
<li><code>【推荐】</code>错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。</li>
</ul>
<h2 id="Android资源文件命名与使用"><a href="#Android资源文件命名与使用" class="headerlink" title="Android资源文件命名与使用"></a>Android资源文件命名与使用</h2><ul>
<li><code>【推荐】</code>资源文件需带模块前缀。</li>
<li><code>【推荐】</code>layout文件的命名方式<ul>
<li>Activity的layout以module_activity开头</li>
<li>Fragment的layout以module_fragment开头</li>
<li>Dialog的layout以module_dialog开头</li>
<li>Include的layout以module_include开头</li>
<li>ListView的item layout以module_list_item开头</li>
<li>RecyclerView的item layout以module_recyle_item开头</li>
<li>GridView的item layout以module_grid_item开头</li>
</ul>
</li>
<li><code>【推荐】</code>drawable资源名称以小写单词+下划线的方式命名，根据分辨率不同放在不同的drawable目录下，建议只使用一套，例如：drawable_xhdpi。采用规则如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模块名_业务功能描述_控件描述_控件状态限定词</span><br><span class="line">module_login_btn_pressed</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>anim资源名称以小写单词+下划线的方式命名，采用以下规则：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模块名_逻辑名称_[方向|序号]</span><br><span class="line">tween 动画资源：尽可能以通用的动画名称命名，如：module_fade_in,module_fade_out,module_push_down_in;</span><br><span class="line">frame 动画资源：尽可能以模块+功能命名+序号。如：module_loading_gray_001</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>color资源使用#AARRGGBB，写入module_colors.xml文件中，命名格式采用以下规则：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//模块名_逻辑名称_颜色,如：</span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">“module_btn_bg_color”</span>&gt;</span>#33b5e5e5<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>dimen资源以小写单词+下划线方式命名，写入module_dimens.xml文件中，采用以下规则：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名_描述信息</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>style资源采用小写单词+下划线方式命名，写入module_styles.xml文件中，采用以下规则：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父style名称.当前style名称</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>string资源文件或者文本用到字符需要全部写入module_string.xml文件中，字符串以小写单词+下划线的方式命名，采用以下规则：模块名_逻辑名称</li>
<li><code>【推荐】</code>Id资源原则上以驼峰法命名，View组件的资源id需要以View的缩写作为前缀。</li>
</ul>
<table>
<thead>
<tr>
<th>控件</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>LinearLayout</td>
<td>ll</td>
</tr>
<tr>
<td>RelativeLayout</td>
<td>rl</td>
</tr>
<tr>
<td>ConstrantLayout</td>
<td>cl</td>
</tr>
<tr>
<td>ListView</td>
<td>lv</td>
</tr>
<tr>
<td>ScrollView</td>
<td>sv</td>
</tr>
<tr>
<td>TextView</td>
<td>tv</td>
</tr>
<tr>
<td>Button</td>
<td>btn</td>
</tr>
<tr>
<td>ImageView</td>
<td>iv</td>
</tr>
<tr>
<td>CheckBox</td>
<td>cb</td>
</tr>
<tr>
<td>RadioButton</td>
<td>rb</td>
</tr>
<tr>
<td>EditText</td>
<td>et</td>
</tr>
</tbody>
</table>
<ul>
<li><code>【推荐】</code>大分辨率图片（单维度超过1000）大分辨率图片建议统一放在xxhdpi目录下管理，否则会导致占用内存成倍数增加</li>
</ul>
<h2 id="Android基本组件"><a href="#Android基本组件" class="headerlink" title="Android基本组件"></a>Android基本组件</h2><blockquote>
<p>Android基本组件指Activity/Fragment/Service/BroadcastReceiver/ContentProvider等</p>
</blockquote>
<ul>
<li><code>【强制】</code>Activity间的数据通信，对于数据量比较大的，避免使用Intent+Parceable的方式，可以考虑EventBus等替代方案，以免造成TransactionTooLargeException.</li>
<li><code>【强制】</code>Activity#onSaveInstanceState()方法不是Activity生命周期方法，也不保证一定会被调用。它是用来在Activity被意外销毁时保存UI状态的，只能用于保存临时性数据，例如UI控件的属性等，不能跟数据的持久化存储混为一谈。持久化存储应该在Activity#onPause()/onStop()中实行。</li>
<li><code>【强制】</code>Activity间通过隐式Intent的跳转，在发出Intent之前必须通过resolveActivity检查，避免找不到合适的调用组件，造成ActivityNotFoundException的异常。</li>
<li><code>【强制】</code>避免在Service#onStartCommand()/onBind()方法中执行耗时操作，如果确有需求，应改用IntentService或采用其他异步机制完成。</li>
<li><code>【强制】</code>避免在BroadcastReceiver#onReceive()中执行耗时操作，如果有耗时工作，应该创建IntentService完成，而不应该在BroadcastReceiver内创建子线程去做。</li>
</ul>
<blockquote>
<p>说明：由于该方法是在主线程执行，如果执行耗时操作时操作会导致UI不流畅，可以使用IntentService，创建HandlerThread或者调用Context#registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)方法等方式，在其他Worker线程执行onReceive方法。BroadcastReceiver#onReceive()方法耗时超过10秒钟，可能会被系统杀死。</p>
</blockquote>
<p>参考：<a href="https://developer.android.com/reference/android/content/BroadcastReceiver.html#onReceive" target="_blank" rel="noopener">https://developer.android.com/reference/android/content/BroadcastReceiver.html#onReceive</a></p>
<ul>
<li><code>【强制】</code>避免使用隐式Intent广播敏感信息，信息可能被其他注册了对应BroadcastReceiver的App接收</li>
</ul>
<blockquote>
<p>说明：通过Context#sendBroadcast()发送的隐式广播会被所有感兴趣的receiver接收，恶意应用注册监听该广播的receiver可能会获取到Intent中传递的敏感信息，并进行其他为先操作。如果发送的广播为使用Context#sendOrderdBroadcast()方法发送的有序广播，优先级较高的恶意Receiver可能直接丢弃该广播，造成服务不可用，或者向广播结果塞入恶意数据。如果广播仅限于应用内，则可以使用LocalBroadcastManager#sendBroadcast()实现，避免敏感信息外泄和Intent拦截风险。</p>
</blockquote>
<ul>
<li><code>【推荐】</code>添加Fragment时，确保FragmentTransaction#commit()在Activity#onPostResume()或者FragmentActivity#onResumeFragments()内调用。不要随意使用FragmentTransaction#commitAlloingStateLoss()来代替。</li>
</ul>
<blockquote>
<p>说明：Activity可能因为各种原因被销毁，Android支持页面被销毁前通过Activity#onSaveInstanceState()保存自己的状态。但如果FragmentTransaction.commit()发生在Activity状态保存之后，就会导致Activity重建、恢复状态时无法还原页面状态，从而可能出错。为避免给用户造成不好的体验，系统会抛出IllegalStateExceptionStateLoss异常。推荐的做法是在Activity的onPostResume()或onResumeFragments()里执行FragmentTransaction.commit()，如有必要也可在onCreate()里执行。不要随意改用FragmentTransaction.commitAllowingStateLoss()或者直接使用try-catch避免crash，这不是问题的根本解决之道，当且仅当你确认Activity重建、恢复状态时，本次commit丢失不会造成影响时才可这么做。</p>
</blockquote>
<p>参考：</p>
<p><a href="https://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html" target="_blank" rel="noopener">https://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html</a><br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/FragmentTransaction.html</a></p>
<ul>
<li><code>【推荐】</code>不要在Activity#onDestroy()内执行释放资源的工作，例如一些工作线程的销毁和停止，因为onDestroy()执行的时机可能较晚。可根据实际需要，在Activity#onPause()/onStop()中结合isFinishing()</li>
<li><code>【推荐】</code>如非必须，避免使用嵌套的Fragment。</li>
</ul>
<blockquote>
<p>说明：嵌套Fragment是在Android API 17添加到SDK以及Support库中的功能，Fragment嵌套使用会有一些坑，容易出现bug，比较常见的问题有如下几种：1) onActivityResult()方法的处理错乱，内嵌的Fragment可能收不到该方法的回调，需要由宿主Fragment进行转发处理；2) 突变动画效果；3) 被继承的setRetainInstance()，导致在Fragment重建时多次触发不必要的逻辑。</p>
</blockquote>
<p>非必须的场景尽可能避免使用嵌套Fragment，如需使用请注意上述问题。</p>
<ul>
<li><code>【推荐】</code>总是使用显式Intent启动或者绑定Service，且不要为服务声明IntentFilter，保证应用的安全性。如果确实需要使用隐式调用，则可为Service提供IntentFilter并从Intent中排出相应的组件名称，但必须打牌使用Intent#setPackage()方法设置Intent的指定包名，这样可以充分消除目标服务的不确定性。</li>
<li><code>【推荐】</code>Service需要以多线程来兵法处理多个启动请求，建议使用IntentService，可避免各种复杂的设置。</li>
</ul>
<blockquote>
<p>说明：Service组件一般运行主线程，应当避免耗时操作，如果有耗时操作应该在Worker线程执行。可以使用IntentService执行后台任务。<br>扩展参考：<a href="https://developer.android.com/guide/components/services.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/services.html</a></p>
</blockquote>
<ul>
<li><code>【推荐】</code>对于只用于应用内的广播，优先使用LocalBroadcastManager来进行注册和发送，LocalBroadcastManager安全性更好，同时拥有更高的运行效率。</li>
</ul>
<blockquote>
<p>说明：对于使用Context#sendBroadcast()等方法发送全局广播的代码进行提示。如果该广播仅用于应用内，则可以使用LocalBroadcastManager来避免广播泄露以及广播被拦截等安全问题，同时相对全局广播本地广播的更高效。</p>
</blockquote>
<ul>
<li><code>【推荐】</code>当前Activity的onPause方法执行结束后才会执行下一个Activity的onCreate方法，所以在onPause方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效率。</li>
<li><code>【强制】</code>不要在Android的Application对象中缓存数据。基础组件之间的数据共享请使用Intent等机制，也可使用SharedPreferences等数据持久化机制。</li>
<li><code>【推荐】</code>使用Toast时，建议定义一个全局的Toast对象，这样可以避免连续显示Toast时不能取消上一次Toast消息的情况（如果你有连续弹出Toast的情况，避免使用Toast.makeText）。</li>
<li><code>【推荐】</code>使用Adapter的时候，如果使用了ViewHolder做缓存，在getView()方法中无论这项convertView的每个子控件是否需要设置属性（比如某个Text设置的文本可能为null，某个按钮的背景色为透明，某控件的颜色为透明等），都需要为其显式设置属性（TextView的文本为空也需要设置setText(“”),透明背景也需要设置），否则在滑动的过程中，因为adapter item复用的原因，会出现内容的显示错乱。</li>
<li><code>【推荐】</code>Activity或者Fragment中动态注册BroadcastReceiver时，registerReceiver()和unregisterReceiver要成对出现。</li>
</ul>
<blockquote>
<p>说明：如果registerReceiver()和unregisterReceiver()不成对出现，则可能导致已经注册的receiver没有在合适的时机注销，导致内存泄漏，占用内存空间，加重SystemService负担。部分华为的机型会对receiver进行资源管控，单个应用注册过多receiver会触发管控模块抛出异常。Activity的生命周期不对应，可能出现多次onResume造成receiver注册多个，但最终只注销一个，其余receiver产生内存泄漏。</p>
</blockquote>
<h2 id="UI与布局"><a href="#UI与布局" class="headerlink" title="UI与布局"></a>UI与布局</h2><ul>
<li><code>【强制】</code>布局中不得不使用ViewGroup多重嵌套，不要使用LinearLayout，改用RelativeLayout，可以有效降低嵌套数。</li>
</ul>
<blockquote>
<p>说明：Android应用页面上任何一个View都需要经过measure/layout/draw三个步骤才能被正确渲染。从xml layout的顶部节点开始进行measure，每个子节点都需要向自己的父节点提供自己的尺寸来决定展示的位置，在此过程中可能还会重新measure（由此可能导致measure的时间消耗为原来的2-3倍）。节点所处位置越深，嵌套带来的measure越多，计算就会越费时。这就是为什么扁平的View结构会性能更好。同时，页面上的View越多，measure/layout/draw所花费的时间就越久。要缩短这个时间，关键是保持View的属性结构尽量扁平，而且要移除所有不需要渲染的View。理想情况下，总共的measure/layout/draw时间应该被很好的控制在16ms以内，以保证滑动屏幕时UI的流畅。要找到那些多余的View（增加渲染延迟的view）,可以用Android Studio Monitor里的Hierarachy Viewer工具，可视化的查看所有的View。</p>
</blockquote>
<p>扩展参考：</p>
<p><a href="https://developer.android.com/studio/profile/hierarchy-viewer.html" target="_blank" rel="noopener">https://developer.android.com/studio/profile/hierarchy-viewer.html</a></p>
<p><a href="http://mrpeak.cn/android/2016/01/11/android-performance-ui" target="_blank" rel="noopener">http://mrpeak.cn/android/2016/01/11/android-performance-ui</a></p>
<p><a href="https://www.safaribooksonline.com/library/view/high-performance-android/9781491913994/ch04.html#figure-story_tree" target="_blank" rel="noopener">https://www.safaribooksonline.com/library/view/high-performance-android/9781491913994/ch04.html#figure-story_tree</a></p>
<ul>
<li><code>【推荐】</code>在Activity中显示对话框或弹出浮层时，尽量使用DialogFragment，而非Dialog/AlertDialog，这样便于随Activity生命周期管理对话框/弹出浮层的生命周期。</li>
<li><code>【推荐】</code>源文件统一采用UTF-8的形式进行编码。</li>
<li><code>【强制】</code>禁止在非ui线程进行view相关操作。</li>
<li><code>【推荐】</code>文本大小使用单位dp，view大小使用单位dp。对于Textview，如果在文字大小确定的情况下推荐使用wrap_content布局避免出现文字显示不全的适配问题。</li>
<li><code>【强制】</code>禁止在设计布局时设置子view和父view中为同样的背景造成页面过度绘制，推荐将不需要显示的布局进行及时隐藏。</li>
<li><code>【推荐】</code>灵活使用布局，推荐使用Merge/ViewStub来优化布局，尽可能多的减少UI布局层级，推荐使用FrameLayout,LinearLayout、RelativeLayout次之。</li>
<li><code>【推荐】</code>在需要时刻刷新某一区域的组件时，建议通过以下方式避免引发全局layout刷新：<ul>
<li>设置固定的view大小的高宽，如倒计时组件等；</li>
<li>调用view的layout方式修改位置，如弹幕组件等；</li>
<li>通过修改canvas位置并且调用invalidate(int i,int t,int r,int b)等方式先定刷新区域；</li>
<li>通过设置一个是否允许requestLayout的变量，然后重写控件的requestlayout/onSizeChanged方法，判断控件的大小没有改变的情况下，当进入requestLayout的时候，直接返回而不调用super的requestLayout方法。</li>
</ul>
</li>
</ul>
<p>生命周期管理对话框/弹出浮层的生命周期。</p>
<ul>
<li><p><code>【推荐】</code>不能在Activity没有完全显示时显示PopWindow和Dialog。生命周期管理对话框/弹出浮层的生命周期。</p>
</li>
<li><p><code>【推荐】</code>尽量不要使用AnimationDrawable，它在初始化的时候就将所有图片加载到内存中，特别占内存，并且还不能释放，释放之后下次进入再次加载时会报错。</p>
</li>
</ul>
<blockquote>
<p>说明：Android的帧动画可以使用AnimationDrawable实现，但是如果你的帧动画中包含过多帧图片，一次性加载所有帧图片所导致的内存消耗会使低端机发生OOM异常。帧动画所使用的图片要注意降低内存消耗，当图片比较大时，容易出现OOM。</p>
</blockquote>
<p>参考：</p>
<p><a href="https://stackoverflow.com/questions/8692328/causing-outofmemoryerror-in-frame-by-frame-animation-in-android" target="_blank" rel="noopener">https://stackoverflow.com/questions/8692328/causing-outofmemoryerror-in-frame-by-frame-animation-in-android</a></p>
<p><a href="https://blog.csdn.net/wanmeilang123/article/details/53929484" target="_blank" rel="noopener">https://blog.csdn.net/wanmeilang123/article/details/53929484</a></p>
<p><a href="https://segmentfault.com/a/1190000005987659" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005987659</a></p>
<p><a href="https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html</a></p>
<ul>
<li><code>【强制】</code>不能使用ScrollView包裹ListView/GridView/ExpandableListView；因为这样会把ListView的所有Item都加载到内存中，要消耗巨大的内存和cpu去绘制页面。</li>
</ul>
<blockquote>
<p>说明：ScrollView中嵌套List或RecyclerView的做法官方明确禁止。除了开发过程中遇到的各种视觉和交互问题，这种做法对性能也有较大损耗。ListView等UI组件自身有垂直滚动功能，也没有必要在嵌套一层ScrollView。目前为了较好的UI体验，更贴近Material Design的设计，推荐使用NestedScrollView。</p>
</blockquote>
<p>参考:</p>
<p><a href="https://developer.android.com/reference/android/widget/ScrollView.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/widget/ScrollView.html</a></p>
<p><a href="https://developer.android.com/reference/android/support/v4/widget/NestedScrollView.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/support/v4/widget/NestedScrollView.html</a></p>
<h2 id="五-进程、线程与消息通信"><a href="#五-进程、线程与消息通信" class="headerlink" title="五 进程、线程与消息通信"></a>五 进程、线程与消息通信</h2><ul>
<li><code>【强制】</code> 不要通过Intent在Android基础组件之间传递大数据(binder transaction缓存为 1MB)，可能导致OOM。</li>
<li><code>【强制】</code> 在Applicaiton的业务初始化代码加入进程判断，确保只在自己需要的进程初始化。特别是后台进程减少不必要的业务初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationextends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function">pulic <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//在所有进程中初始化</span></span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">//仅在主进程中初始化</span></span><br><span class="line">       <span class="keyword">if</span>(mainProcess)&#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//仅在后台进程中初始化</span></span><br><span class="line">       <span class="keyword">if</span>(bgProcess)&#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code> 新建线程时，必须通过线程池提供（AsyncTask或者ThreadPoolExecutor或者其他形式自定义的线程池），不允许在应用中自行显式创建线程。</li>
</ul>
<blockquote>
<p>说明：使用线程池的好处是在减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能在成系统创建大量同类的线程而导致消耗完内存或者“过度切换”的问题。另外创建匿名线程不便于后续的资源使用分析，对性能分析会造成困扰。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> NUMBER_OF_CORES = Runtime.getRuntime().avilableProcessors();</span><br><span class="line"><span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">1</span>;</span><br><span class="line">TimeUnit KEEP_ALIVE_TIME_UNIT = TimeUnit.SECONDS;</span><br><span class="line">BlockQueue&lt;Runnable&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(NUMBER_OF_CORES, NUMBER_OF_CORES*<span class="number">2</span>, KEEP_ALIVE_TIME, KEEP_ALIVE_TIME_UNIT, taskQueue, <span class="keyword">new</span> BackgroundThreadFactory(), <span class="keyword">new</span> DefaultRejectedExecutionHandler());</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line">executorService.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例:</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//操作语句</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>扩展参考：<a href="https://blog.mindorks.com/threadpoolexecutor-in-android-8e9d22330ee3" target="_blank" rel="noopener">https://blog.mindorks.com/threadpoolexecutor-in-android-8e9d22330ee3</a></p>
<ul>
<li><code>【强制】</code> 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让开发者更加明确线程池的运行规则，规避资源耗尽的风险。</li>
</ul>
<blockquote>
<p>说明：Executors返回的线程池对象的弊端：1.FixedThreadPool和SingleThreadPool：允许请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM；2.CachedThreadPool和ScheduledThreadPool：允许请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">int</span> NUMBER_OF_CORES = Runtime.getRuntime().avilableProcessors();</span><br><span class="line"><span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">1</span>;</span><br><span class="line">TimeUnit KEEP_ALIVE_TIME_UNIT = TimeUnit.SECONDS;</span><br><span class="line">BlockQueue&lt;Runnable&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(NUMBER_OF_CORES, NUMBER_OF_CORES*<span class="number">2</span>, KEEP_ALIVE_TIME, KEEP_ALIVE_TIME_UNIT, taskQueue, <span class="keyword">new</span> BackgroundThreadFactory(), <span class="keyword">new</span> DefaultRejectedExecutionHandler());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
<p>扩展参考 <a href="http://dev.bizo.com/2014/06/cached-thread-pool-considered-harmlful.html" target="_blank" rel="noopener">http://dev.bizo.com/2014/06/cached-thread-pool-considered-harmlful.html</a></p>
<ul>
<li><code>【强制】</code> 子线程中不能更新界面，更新界面必须在主线程中进行，网络操作不能再主线程中调用。</li>
<li><code>【强制】</code> 不要在非ui线程中初始化ViewStub，否则会返回null；</li>
<li><code>【推荐】</code> 尽量减少不同APP之间的进程间通信以及拉起行为。拉起导致占用系统资源，影响用户体验。</li>
<li><code>【推荐】</code> 新建线程时，定义能识别自己业务的线程名称，便于性能优化和问题排查。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Tread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"ThreadName"</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code> ThreadPoolExectuor设置线程存活时间(setKeepAliveTime)，确保空闲时线程能被释放。</li>
<li><code>【推荐】</code> 禁止在多进程之间用SharedPreferences共享数据，虽然可以(MODE_MULTI_PROCESS)，但官方已不推荐。</li>
<li><code>【推荐】</code> 谨慎使用Android的多进程，多进程虽然能够降低主进程的内存压力，但会遇到如下问题：<ul>
<li>不能实现完全退出所有Activity的功能</li>
<li>首次进入新启动进程的页面时会有延时的现象（有可能黑屏、白屏几秒，是白屏还是黑屏和新Activity的主题有关）</li>
<li>应用内多进程时，Application实例化多次，需要考虑各个模块是否都需要在所有进程中初始化</li>
<li>多进程间通过SharedPreferences共享数据时不稳定</li>
</ul>
</li>
</ul>
<h2 id="六-文件与数据库"><a href="#六-文件与数据库" class="headerlink" title="六 文件与数据库"></a>六 文件与数据库</h2><ul>
<li><code>【强制】</code> 任何时候不要硬编码文件路径，请使用Android文件系统API访问<ul>
<li>android.os.Environment#getExternalStorageDirectory()</li>
<li>android.os.Environment#getExternalStoragePublicDirectory()</li>
<li>android.content.Context#getFilesDir()</li>
<li>android.content.Context#getCacheDir()</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：Android应用提供内部和外部存储，分别用于存放应用自身数据以及应用产生的用户数据。可以通过相关API接口获取对应的目录，进行文件操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getDir</span><span class="params">(String alName)</span></span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), alName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!file.mkdirs())&#123;</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"Dirctory not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getDir</span><span class="params">(String alName)</span></span>&#123;</span><br><span class="line">    <span class="comment">//任何时候都不要硬编码文件路径，这不仅存在安全隐患，也让app更容易出现适配问题</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"/mnt/sdcard/Download/Album"</span>, alName);</span><br><span class="line">    <span class="keyword">if</span>(!file.mkdirs())&#123;</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"Dirctory not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展参考：</p>
<p><a href="https://developer.android.com/training/data-storage/files.html" target="_blank" rel="noopener">https://developer.android.com/training/data-storage/files.html</a></p>
<p><a href="https://developer.android.com/reference/android/os/Environment.html#getExternalStorageDirectory" target="_blank" rel="noopener">https://developer.android.com/reference/android/os/Environment.html#getExternalStorageDirectory</a></p>
<ul>
<li><code>【强制】</code> 当使用外部存储时，必须检查外部存储的可用性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="comment">//读写检查</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> is <span class="title">ExternalStorageWritable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span>(Environment.MEDIA_MOUNTED.equals(state))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只读检查</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> is <span class="title">ExternalStorageReadable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span>(Environment.MEDIA_MOUNTED_READ_ONLY.equals(state))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code> 应用间共享文件时，不要通过放宽文件系统权限的方式去实现，而应使用FileProvider。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//正例：</span><br><span class="line"><span class="comment">&lt;!--AndroidManifest.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">"com.example.fileprovider"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:resource</span>=<span class="string">"@xml/provider_paths"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--res/xml/provider_pahts.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">path</span>=<span class="string">"album/"</span> <span class="attr">name</span>=<span class="string">"myimages"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAlumnImage</span><span class="params">(Stirng imagePath)</span></span>&#123;</span><br><span class="line">    File image = <span class="keyword">new</span> File(imagePath);</span><br><span class="line">    Intent getAlbumImageIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    Uri imageUri = FileProvider.getUriForFile(<span class="keyword">this</span>,<span class="string">"com.example.provider"</span>,image);</span><br><span class="line">    getAlbumImageIntent.getExtra(MediaStore.EXTRA_OUTPUT,imageUri);</span><br><span class="line">    startActivityForResult(taskPhotoIntent.REQUEST_GET_ALBUMIMAGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAlumnImage</span><span class="params">(Stirng imagePath)</span></span>&#123;</span><br><span class="line">    File image = <span class="keyword">new</span> File(imagePath);</span><br><span class="line">    Intent getAlbumImageIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    <span class="comment">//不要使用 file:// 的URI分享文件给别的应用，包括但不限于Intent</span></span><br><span class="line">    Uri imageUri = FileProvider.getUriForFile(<span class="keyword">this</span>,<span class="string">"com.example.provider"</span>,image);</span><br><span class="line">    getAlbumImageIntent.getExtra(MediaStore.EXTRA_OUTPUT,imageUri);</span><br><span class="line">    startActivityForResult(taskPhotoIntent.REQUEST_GET_ALBUMIMAGE);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code> SharedPreferences中只能存储简单数据类型(int/boolean/String等)，复杂数据类型建议使用文件、数据库等其他方式存储。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSettings</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SharedPreferences mySharedPreferences = getSharedPreferences(<span class="string">"settings"</span>, Activity.MODE_PRIVATE);</span><br><span class="line">    SharedPreferences.Editor editor = mySharedPreferences.edit();</span><br><span class="line">    editor.putString(<span class="string">"id"</span>,<span class="string">"foo"</span>);</span><br><span class="line">    editor.putString(<span class="string">"nick"</span>,<span class="string">"bar"</span>);</span><br><span class="line">    <span class="comment">//不要把复杂数据类型转成String存储</span></span><br><span class="line">    editor.apply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code> SharedPrefernece提交数据时，尽量使用Editor#apply()，而非Editor#commit()。一般来说，仅当需要确定提交结果，并据此有后续操作时，才使用Editor#commit().</li>
</ul>
<blockquote>
<p>说明：SharedPreference相关修改使用apply方法进行提交会先写入内存，然后异步写入磁盘，commit方法是直接写入磁盘。如果频繁操作的话apply的性能会优于commit，apply会将最后修改内容写入磁盘。但是如果希望里可获取存储操作的结果，并据此做相应的其他操作，应当使用commit。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSettingsAsync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SharedPreferences mySharedPreferences = getSharedPreferences(<span class="string">"settings"</span>, Activity.MODE_PRIVATE);</span><br><span class="line">    SharedPreferences.Editor editor = mySharedPreferences.edit();</span><br><span class="line">    editor.putString(<span class="string">"id"</span>,<span class="string">"foo"</span>);</span><br><span class="line">    editor.apply();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSettings</span><span class="params">()</span></span>&#123;</span><br><span class="line">     SharedPreferences mySharedPreferences = getSharedPreferences(<span class="string">"settings"</span>, Activity.MODE_PRIVATE);</span><br><span class="line">    SharedPreferences.Editor editor = mySharedPreferences.edit();</span><br><span class="line">    editor.putString(<span class="string">"id"</span>,<span class="string">"foo"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!editor.commit())&#123;</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"Failed to commit setting changes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">editor.putLong(<span class="string">"key_name"</span>,<span class="string">"long value"</span>);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure>
<p>扩展参考：<a href="https://developer.android.com/reference/android/content/SharedPreferences.Editor.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/content/SharedPreferences.Editor.html</a></p>
<ul>
<li><code>【强制】</code> 数据库Cursor必须确保使用完后关闭，以免内存泄漏。</li>
</ul>
<blockquote>
<p>说明：Cursor是对数据库查询结果集管理的一个类，当查询的结果集较小时，消耗内存不易察觉。但是当结果集较大，长时间重复操作会导致内存消耗过大，需要开发者在操作完成后手动关闭Cursor。数据库Cursor在创建及使用时，可能发生各种异常，无论程序是否正常结束，必须在最后确保Cursor正确关闭，以避免内存泄漏。同时，如果Cursor的使用还牵涉多线程场景，那么需要自行保证操作同步。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePhoto</span><span class="params">(SQLiteDatabase db, String userId)</span></span>&#123;</span><br><span class="line">    Cursor cursor;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        cursor = db.query(TUserPhoto, <span class="keyword">new</span> String[]&#123;<span class="string">"userId"</span>,<span class="string">"content"</span>&#125;, <span class="string">"userId=?"</span>,<span class="keyword">new</span> String[]&#123;userId&#125;,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Excption e)&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cursor!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePhotos</span><span class="params">(SQLiteDatebase db, String userId)</span></span>&#123;</span><br><span class="line">    Cursor cursor = db.query(TUserPhoto, <span class="keyword">new</span> String[]&#123;<span class="string">"userId"</span>,<span class="string">"content"</span>&#125;, <span class="string">"userId=?"</span>,<span class="keyword">new</span> String[]&#123;userId&#125;,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//不能放任cursor不关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code> 多线程操作写入数据库时，需要使用事务，以避免出现同步问题。</li>
</ul>
<blockquote>
<p>说明：Android通过SQLiteOpenHelper获取数据库SQLiteDatebase实例，Helper中会自动缓存已经打开的SQLiteDatabase实例，单个App中应使用SQLiteOpenHelper的单例模式确保数据库连接唯一。由于SQLite自身是数据库级锁，单个数据库操作是保证线程安全的（不能同时写入），transaction时一次院子操作，因此处于十五中的操作是线程安全的。若同时打开多个数据库连接，并通过多线程写入数据库，会导致数据库异常，提示数据库已被锁住。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inserUserPhoto</span><span class="params">(SQLiteDatabase db, String userId, String content)</span></span>&#123;</span><br><span class="line">    ContentValues cv = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    cv.put(<span class="string">"userId"</span>,userId);</span><br><span class="line">    cv.put(<span class="string">"content"</span>, content);</span><br><span class="line">    db.beginTransaction();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        db.insert(TUserPhoto, <span class="keyword">null</span>, cv);</span><br><span class="line">        <span class="comment">//其他操作</span></span><br><span class="line">        db.setTransactionSuccessful();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        db.endTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inserUserPhoto</span><span class="params">(SQLiteDatabase db, String userId, String content)</span></span>&#123;</span><br><span class="line">    ContentValues cv = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    cv.put(<span class="string">"userId"</span>,userId);</span><br><span class="line">    cv.put(<span class="string">"content"</span>, content);</span><br><span class="line">    db.beginTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展参考：</p>
<p><a href="https://nfrolov.wordpress.com/2014/08/16/android-sqlitedatabase-locking-and-multi-threading" target="_blank" rel="noopener">https://nfrolov.wordpress.com/2014/08/16/android-sqlitedatabase-locking-and-multi-threading</a><br><a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#beginTransaction()" target="_blank" rel="noopener">https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#beginTransaction()</a><br><a href="https://www.androiddesignpatterns.com/2012/05/correctly-managing-your-sqlite-database.html" target="_blank" rel="noopener">https://www.androiddesignpatterns.com/2012/05/correctly-managing-your-sqlite-database.html</a><br><a href="https://www.jianshu.com/p/57eb08fe071d" target="_blank" rel="noopener">https://www.jianshu.com/p/57eb08fe071d</a></p>
<ul>
<li><code>【推荐】</code>大数据写入数据库时，请使用事务或其他能够提高I/O效率的机制，保证执行速度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inserBulk</span><span class="params">(SQLiteDatabase db, ArrayList&lt;UserInfo&gt; users)</span></span>&#123;</span><br><span class="line">    db.beginTrasaction();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; users.size; i++)&#123;</span><br><span class="line">        ContentValues cv = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        cv.put(<span class="string">"userId"</span>,users[i].userId);</span><br><span class="line">        cv.put(<span class="string">"content"</span>, users[i].content);</span><br><span class="line">        db.insert(TUserPhoto, <span class="keyword">null</span>, cv)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其他操作</span></span><br><span class="line">        db.setTransactionSuccessful();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        db.endTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code> 执行SQL语句时，应使用SQLiteDatabase#insert()/update()/delete()，不要使用SQLiteDatabase#execSQL()，以免SQL注入风险。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUserPhoto</span><span class="params">(SQLiteDatabase db, String userId, String content)</span></span>&#123;</span><br><span class="line">    ContentValues cv = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    cv.put(<span class="string">"content"</span>, content);</span><br><span class="line">    String[] args = &#123;String.valueOf(userId)&#125;;</span><br><span class="line">    <span class="keyword">return</span> db.update(TUserPhoto, cv, <span class="string">"userId=?"</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUserPhoto</span><span class="params">(SQLiteDatabase db, String userId, String content)</span></span>&#123;</span><br><span class="line">    String sqlStmt = String.format(<span class="string">"UPDATE %s SET content=%s WHERE userId=%s"</span>, TUserPhoto, userId, content);</span><br><span class="line">    <span class="comment">//请提高安全意识，不要直接执行字符串作为SQL语句</span></span><br><span class="line">    db.execSQL(sqlStmt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code> 如果ContentProvider管理的数据存储在SQL数据库中，应该避免将不受信任的外部数据直接凭借在原始SQL语句中，可使用一个用于将<code>?</code>作为可替换参数的选择自居以及一个单独的选择参数数组，会避免SQL注入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="comment">//使用一个可替换参数</span></span><br><span class="line">String mSelectionClause = <span class="string">"var = ?"</span></span><br><span class="line">String[] selectionArgs = &#123;<span class="string">""</span>&#125;;</span><br><span class="line">selectionArgs[<span class="number">0</span>] = mUserInput;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="comment">//拼接用户输入内容和列名</span></span><br><span class="line">String mSelectionClause = <span class="string">"var ="</span> + mUserInput;</span><br></pre></td></tr></table></figure>
<h2 id="七-Bitmap-Drawable与动画"><a href="#七-Bitmap-Drawable与动画" class="headerlink" title="七 Bitmap/Drawable与动画"></a>七 Bitmap/Drawable与动画</h2><ul>
<li><code>【强制】</code>加载大图片或者一次性加载多张图片，应该在异步线程中进行。图片的加载，涉及到IO操作，以及CPU密集操作，很可能引起卡顿</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>,<span class="title">Void</span>,<span class="title">Bitmap</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在后台进行图片解码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Intege...params)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Bitmap bitmap = BitmapFactory.decodeFile(<span class="string">"some path"</span>);</span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">Button btnLoadImage = (Button)findViewById(R.id.btn);</span><br><span class="line">btnLoadImage.setOnClickListener(<span class="keyword">new</span> OnClickListner()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        Bitmap bitmap = BitmapFactory.decodeFile(<span class="string">"some path"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>在ListView,ViewPager,RecyclerView,GridView等组件中使用图片时，应做好图片的缓存，避免始终持有图片导致内存泄漏，也避免重复创建图片，引起性能问题。建议使用<a href="https://github.com/facebook/fresco" target="_blank" rel="noopener">Fresco</a>/<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a>等图片库。</li>
<li><code>【强制】</code>png图片使用tinypng或者类似工具压缩处理，减少包体积。</li>
<li><code>【推荐】</code>应根据实际展示需要，压缩图片，而不是直接显示原图。手机屏幕比较小，直接先是原图，并不会增加视觉上的收益，但是却会消耗大量宝贵的内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resouces res, <span class="keyword">int</span> resId, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span></span>&#123;</span><br><span class="line">    <span class="comment">//首先通过 inJustDecodeBounds=true获得图片尺寸</span></span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Option opitons = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeResouce(res,resId,options);</span><br><span class="line">    <span class="comment">//然后根据图片分辨率以及我们实际需要展示的大小，计算压缩率</span></span><br><span class="line">    options.inSampleSize = calculateInSampleSize(options,reqWidth, reqHeight);</span><br><span class="line">    <span class="comment">//设置压缩率，并解码</span></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>使用完毕的图片，应该及时回收，释放宝贵的内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">loadBitmapAsync(<span class="keyword">new</span> OnResult(result)&#123;</span><br><span class="line">    bitmap = result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//---使用该Bitmap--//</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用结束，在2.3.3及以下需要调用recycle()函数，在2.3.3以上GC会自动管理，除非你明确不需要在使用。</span></span><br><span class="line"><span class="keyword">if</span>(Build.VERSION.SDK_INK &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">    bitmap.recycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bitmap = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>针对不同的屏幕密度，提供对应的图片资源，使内存占用和显示效果达到合理的平衡。如果为了节省宝体积，可以在不影响UI效果的前提下，省略低密度图片。</li>
<li><code>【强制】</code>在Activity.onPause()或Activity.onStop()回调中关闭当前activity正在执行的动画。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">    ImageView mImageView;</span><br><span class="line">    Animation mAnimation;</span><br><span class="line">    Button mBtn;</span><br><span class="line">    <span class="comment">/** 首次创建activity时调用**/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstaceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line">        setContentVew(R.layout.main);</span><br><span class="line">        mImageView = (ImageView)findViewById(R.id.ImageVIew01);</span><br><span class="line">        mAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>,R.anim.anim);</span><br><span class="line">        mBtn = (Button)findViewById(R.id.Button01);</span><br><span class="line">        mBtn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                mImageView.startAnimation(mAnimation)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//页面退出，及时清理动画资源</span></span><br><span class="line">        mImageView.clearAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>在动画或者其他异步任务结束时，应该考虑回调时刻的环境是否还支持业务处理。例如Activity的onStop()函数已经执行，且在该函数中主动释放了资源，此时回调中如果不做判断就会空指针崩溃。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">    ImageView mImageView;</span><br><span class="line">    Animation mAnimation;</span><br><span class="line">    Button mBtn;</span><br><span class="line">    <span class="comment">/** 首次创建activity时调用**/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstaceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line">        setContentVew(R.layout.main);</span><br><span class="line">        mImageView = (ImageView)findViewById(R.id.ImageVIew01);</span><br><span class="line">        mAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>,R.anim.anim);</span><br><span class="line">        mAnimation.setAnimationListener(<span class="keyword">new</span> AnimationListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation arg0)</span></span>&#123;</span><br><span class="line">                <span class="comment">//判断一下资源是否被释放了</span></span><br><span class="line">                <span class="keyword">if</span>(mImageView!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    mImageView.clearAnimation();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mImageView.startAnimation(mAnimation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>使用inBitmap重复利用内存空间，避免重复开辟新内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromFile</span><span class="params">(String filename, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight, ImageCache cache)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    ...</span><br><span class="line">    BitmapFactory.decodeFile(filename,options);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果在Honeycomb或更新版本系统中运行，尝试使用inBitmap</span></span><br><span class="line">    <span class="keyword">if</span>(Utils.hasHoneycomb())&#123;</span><br><span class="line">        addInBitmapOptions(options,cache);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeFile(filename, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInBitmapOptions</span><span class="params">(BitmapFactory.Options options, ImageCache cache)</span></span>&#123;</span><br><span class="line">    <span class="comment">//inBitmap 只处理可变的位图，所以强制返回可变的位图</span></span><br><span class="line">    options.inMutable=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(cache!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Bitmap inBitmap = cache.getBitmapFromReusableSet(Options);</span><br><span class="line">        <span class="keyword">if</span>(inBitmap!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            options.inBitmap=inBitmap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>使用ARGB_565代替ARGB_888，在不怎么降低视觉效果的前提下，减少内存占用。</li>
</ul>
<blockquote>
<p>说明：android.graphics.Bitmap.Config类中关于图片颜色的存储方式定义：ALPHA_8代表8位Alpha位图，ARGB_4444代表16位ARGB图，ARGB_8888代表32位ARGB位图，RGB_565代表8位RGB位图。位图数越高，存储的颜色信息越多，图像也就越逼真。大多数场景使用的是ARGB_8888和RGB_565，RGB_565能够在保证图片质量的情况下大大减少内存的开销，是解决OOM的一种方法。但是一定要注意RGB_565是没有透明度的，如果图片本身需要保留透明度，那么久不能使用RGB_565。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">Config config = drawableSave.getOpacity()!=PixelFormat.OPAQUE?Config.ARGB_8888:Config.RGB_565;</span><br><span class="line">Bitmap bitmap = Bitmap.createBitmap(w,h,config);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">Bitmap newbitmap = Bitmap.createBitmap(width,height,Config.ARGB_8888);</span><br></pre></td></tr></table></figure>
<p>扩展参考：</p>
<p><a href="https://www.jianshu.com/p/294b390eb6f7" target="_blank" rel="noopener">https://www.jianshu.com/p/294b390eb6f7</a></p>
<p><a href="https://www.programcreek.com/java-api-examples/android.graphics.Bitmap.Config" target="_blank" rel="noopener">https://www.programcreek.com/java-api-examples/android.graphics.Bitmap.Config</a></p>
<ul>
<li><code>【推荐】</code>尽量减少Bitmap(BitmapDrawable)的使用，尽量使用纯色(ColorDrawable)、渐变色(GradientDrawable)、StateSelector(StateListDrawale)等与Shape结合的形式构建绘图。</li>
<li><code>【推荐】</code>谨慎使用gif图片，注意限制每个页面允许同时播放的gif图片，以及单个gif图片的大小</li>
<li><code>【参考】</code>大图片资源不要直接打包到apk，可以考虑通过文件仓库远程下载，减小包体积。</li>
<li><code>【推荐】</code>根据设备性能，选择性开启复杂动画，以实现一个整体较优的性能和体验；</li>
<li><code>【推荐】</code>在有强依赖onAnimationEnd回调的交互时，如动画播放完毕才能操作页面，onAnimationEnd 可能会因各种异常没被回调(参考 <a href="https://stackoverflow.com/questions/5474923/onanimationend-is-not-getting-called-onanimationstart-works-fine" target="_blank" rel="noopener">https://stackoverflow.com/questions/5474923/onanimationend-is-not-getting-called-onanimationstart-works-fine</a>)，建议加上超市保护或通过postDelay替代onAnimationEnd。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">View v = findViewById(R.di.xxxViewID);</span><br><span class="line"><span class="keyword">final</span> FadeUpAnimation anim = <span class="keyword">new</span> FadeUpAnimation(v);</span><br><span class="line">anim.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());</span><br><span class="line">anim.setDuration(<span class="number">1000</span>);</span><br><span class="line">anim.setFillAfter(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            v.clearAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,anim.getDuration());</span><br><span class="line">v.startAnimation(anim);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>当View Animation执行结束时，调用View.clearAnimation()释放相关资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">View v = findViewById(R.di.xxxViewID);</span><br><span class="line"><span class="keyword">final</span> FadeUpAnimation anim = <span class="keyword">new</span> FadeUpAnimation(v);</span><br><span class="line">anim.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());</span><br><span class="line">anim.setDuration(<span class="number">1000</span>);</span><br><span class="line">anim.setFillAfter(<span class="keyword">true</span>);</span><br><span class="line">anim.setAnimationListener(<span class="keyword">new</span> AnimationListner()&#123;</span><br><span class="line">    <span class="comment">//判断一下资源是否被释放了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimaitonEnd</span><span class="params">(Animation arg0)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            v.clearAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">v.startAnimation(anim);</span><br></pre></td></tr></table></figure>
<h2 id="八-安全"><a href="#八-安全" class="headerlink" title="八 安全"></a>八 安全</h2><ul>
<li><code>【强制】</code>使用PendingIntent时，禁止使用空intent，同时禁止使用隐式Intent</li>
</ul>
<blockquote>
<p>说明：1)使用PendingIntent时，使用了空Intent，会导致恶意用户劫持修改Intent的内容。禁止使用一个空Intent去构造PendingIntent，构造PendingIntent的Intent一定要设置ComponentName或者action.2)PendingIntent可以让其他App中的代码像是运行在自己App中。PendingIntent的intent接收方在使用该intent时与发送方有相同的权限。在使用PendingIntent时，PendingIntent中包装的intent如果是隐式是Intent，容易遭到劫持，导致信息泄露。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SomeActivity.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">1</span>,intent,PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    pendingIntent.send();</span><br><span class="line">&#125;<span class="keyword">catch</span>(PendingIntent.CaceledException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例1：</span></span><br><span class="line">Bundle addAccountOptions = <span class="keyword">new</span> Bundle();</span><br><span class="line">mPendingIntent = PendingIntent.getBroadcast(<span class="keyword">this</span>,<span class="number">0</span>,<span class="keyword">new</span> Intent, <span class="number">0</span>);</span><br><span class="line">addAccountOptions.putParcelable(KEY_CALLER_IDENITY,mPendingIntent);</span><br><span class="line">addAccountOptions.putBoolean(EXTRA_HAS_MULTIPLE_USERS, Utils.hasMultipleUsers(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">AccountManager.get(<span class="keyword">this</span>).addAccount(accountType, <span class="keyword">null</span>, <span class="keyword">null</span>, addAccountOptions, <span class="keyword">null</span>, mCallback, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例2：</span></span><br><span class="line"><span class="comment">//mPendingIntent是通过new Intent()构造原始Intent的，所以为“双无”Intent，这个PendingIntent最终被通过AccountManager.addAcount方法传递给了恶意App接口。</span></span><br><span class="line"></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.test.pushservice.aciton.METHOD);</span></span><br><span class="line"><span class="string">intent.addFlags(32);</span></span><br><span class="line"><span class="string">intent.putExtra("</span>app<span class="string">", PendingIntent.getBroadcast(this,0,intent,0));</span></span><br></pre></td></tr></table></figure>
<p>扩展参考：</p>
<p><a href="https://developer.android.com/reference/android/app/PendingIntent.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/PendingIntent.html</a></p>
<p><a href="https://wiki.sei.cmu.edu/confluence/display/android/DRD21-J.+Always+pass+explicit+intents+to+a+PendingIntent" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/android/DRD21-J.+Always+pass+explicit+intents+to+a+PendingIntent</a></p>
<p><a href="http://www.droidsec.cn/android-broadcastanywhere%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90" target="_blank" rel="noopener">http://www.droidsec.cn/android-broadcastanywhere%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</a></p>
<ul>
<li><code>【强制】</code>禁止使用常量初始化矢量参数构建IvParameterSpec，建议IV通过随机方式产生。</li>
</ul>
<blockquote>
<p>说明：使用固定初始化向量，结果密码文本可预测性会高很多，容易受到字典式攻击。iv的作用主要是用于产生密文的第一个block，以使最终生成的密文产生差异（明文相同的情况下），使密码攻击变得困难，除此之外iv并无其他用途。因此iv通过随机方式产生是一种十分简便、有效的途径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">byte</span>[] rand = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">SecureRandom r = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">r.nextByte(rand);</span><br><span class="line">IvParameterSpec iv = <span class="keyword">new</span> IvParamterSpec(rand);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">IvParameterSpec iv = <span class="keyword">new</span> IvParamterSpec(<span class="string">"1234567890"</span>.getBytes());</span><br><span class="line">System.out.println(iv.getIV());</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>将android:allowbackup属性设置为false，防止adb backup导出数据</li>
</ul>
<blockquote>
<p>说明：在AndroidManifest.xml文件中为了方便对程序数据的备份和恢复，在Android API level 8以后增加了android:allowBackup属性。默认情况下这个属性值为true，故当allowBackup标志值为true时，即可通过adb backup和adb restore来备份和恢复应用程序数据。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//正例：</span><br><span class="line"><span class="tag">&lt;<span class="name">applicaiton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allow</span><span class="attr">Backup</span>=<span class="string">"fasle"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:largeHeap</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"@drawable/test_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>在实现的HostnameVerifier子类中，需要使用verify函数校验服务器主机名的合法性，否则会导致恶意程序利用中间人攻击绕过主机校验。</li>
</ul>
<blockquote>
<p>说明：在握手期间，如果URL的主机名和服务器的标识主机名不匹配，则验证机制可以回调此接口的实现程序来确定是否应该允许此连接。如果回调内实现不恰当，默认接收所有域名，则有安全风险。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">HostnameVerifier hnv = <span class="keyword">new</span> HostnameVerifier()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession sessiont)</span></span>&#123;</span><br><span class="line">        <span class="comment">//总是返回true，接收任意域名服务器</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"yourhostname"</span>.equals(hostname))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            HostnameVerifier hv = HttpURLConnection.getDefaultHostnameVerifier();</span><br><span class="line">            <span class="keyword">return</span> hv.verify(hostname,session)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">HttpsURLConnection.setDefaultHostnameVerifier(hnv);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">HostnameVerifier hnv = <span class="keyword">new</span> HostnameVerifier()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession sessiont)</span></span>&#123;</span><br><span class="line">        <span class="comment">//总是返回true，接收任意域名服务器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">HttpsURLConnection.setDefaultHostnameVerifier(hnv);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>利用X509TrustManager子类中的checkServerTrusted函数校验服务器端证书的合法性。</li>
</ul>
<blockquote>
<p>说明：在实现的X509TrustManager子类中未对服务端的证书做校验，这样会导致不被信任的证书绕过证书校验机制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">TrustManager tm = <span class="keyword">new</span> X509TrustManager()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span><span class="keyword">throws</span> CertificateExcepiton</span>&#123;</span><br><span class="line">        <span class="comment">//do nothing,接收任意客户端证书</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span>hrows CertificateExcepiton</span>&#123;</span><br><span class="line">        <span class="comment">//do nothing,接收任意服务端证书</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sslContext.init(<span class="keyword">null</span>,<span class="keyword">new</span> TrustManager[]&#123;tm&#125;,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>META-INF目录中不能包含如.apk/.odex/.so等敏感文件，该文件夹没有经过签名，容易被恶意替换。</li>
<li><code>【强制】</code>Receiver/Provider不能在毫无权限控制的情况下将android:export设置为true。</li>
<li><code>【参考】</code>数据存储在Sqlite或者轻量级存储需要对数据进行加密，取出来的时候进行解密。</li>
<li><code>【强制】</code>阻止WebView通过file:schema方式访问本地敏感数据。</li>
<li><code>【强制】</code>不要广播敏感信息，只能在本应用使用LocalBroadcast，避免被别的应用收到，或者setPackage做限制。</li>
<li><code>【强制】</code>不要把敏感信息打印到log中</li>
</ul>
<blockquote>
<p>说明：在App的开发过程中，为了方便调试，通常会使用log函数输出一些关键流程的信息，这些信息中通常会包含敏感内容，如执行流程、明文的用户名密码等，这会让攻击者更加容易了解App内部结构方便破解和攻击，甚至直接获取到有价值的敏感信息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">String username = <span class="string">"log_leak"</span>;</span><br><span class="line">String password = <span class="string">"log_leak_pwd"</span>;</span><br><span class="line">Log.d(<span class="string">"MY_APP"</span>,<span class="string">"username"</span> + username);</span><br><span class="line">Log.d(<span class="string">"MY_APP"</span>,<span class="string">"password"</span> + password, <span class="keyword">new</span> Throwable());</span><br><span class="line">Log.d(<span class="string">"MY_APP"</span>,<span class="string">"send message to server"</span>);</span><br><span class="line"><span class="comment">//以上代码使用Log.d/Log.v打印程序的执行过程的username等调试信息，日志没有关闭，攻击者可以直接从Logcat读取这些敏感信息。所以在产品的线上版本中关闭调试接口，不要输出敏感信息。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>对于内部使用的组件，显示设置组件的”android:exported”属性为false。</li>
</ul>
<blockquote>
<p>说明：Android应用使用Intent机制在组件之间传递数据，如果应用在使用getIntent()/getAction()/Intent/getXXXExtra()获取到空数据、异常或者畸形数据时没有进行异常捕获，应用就会发生Crash，应用不可使用（本地拒绝服务）。恶意应用可通过向受害者应用发送此空数据、异常或者机型数据从而使应用产生本地拒绝服务。</p>
</blockquote>
<ul>
<li><code>【强制】</code>应用发布前确保android:debuggable属性设置为false。</li>
<li><code>【强制】</code>使用Intent Scheme URL需要做过滤。</li>
</ul>
<blockquote>
<p>说明：如果浏览器支持Intent Scheme Uri语法，如果过滤不当，那么恶意用户可能通过浏览器js代码进行一些恶意行为，比如盗取cookie等。如果使用了Intent.parseUri函数，获取的intent必须严格过滤，intent至少包含addCategory(“android.intent.category.BROWASABLE”)，setComponent(null)，setSelector(null)3个策略。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="comment">//将intnet scheme URL转换为intent对象</span></span><br><span class="line">Intent intent = Intent.parseUri(uri);</span><br><span class="line"><span class="comment">//禁止没有BROWSABLE categroy的情况下启动activity</span></span><br><span class="line">intent.addCategory(<span class="string">"android.intent.category.BROWSABLE"</span>);</span><br><span class="line">intent.setComponent(<span class="keyword">null</span>);</span><br><span class="line">intent.setSelector(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//使用intent启动activity</span></span><br><span class="line">context.startActivityIfNeeded(intent,-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">Intent intent = Intent.parseUri(uri.toString.trim().substring(<span class="number">15</span>),<span class="number">0</span>);</span><br><span class="line">intent.addCategory(<span class="string">"android.intent.category.BROWSABLE"</span>);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>扩展参考：</p>
<p><a href="https://jaq.alibaba.com/community/art/show?articleid=265" target="_blank" rel="noopener">https://jaq.alibaba.com/community/art/show?articleid=265</a></p>
<p><a href="https://www.mbsd.jp/Whitepaper/IntentScheme.pdf" target="_blank" rel="noopener">https://www.mbsd.jp/Whitepaper/IntentScheme.pdf</a></p>
<ul>
<li><code>【强制】</code>密钥加密存储或者经过变形处理后用于加解密运算，切勿硬编码到代码中。</li>
</ul>
<blockquote>
<p>说明：应用程序在加解密时，使用硬编码在程序中的密钥，攻击者通过反编译拿到密钥可以轻易解密App通信数据。</p>
</blockquote>
<ul>
<li><code>【强制】</code>将所需要动态加载的文件放置在apk内部，或应用私有目录中，如果应用必须要把所加载的文件放置在可被其他应用读写的目录中（比如sdcard），建议对不可信的加载源进行完整性校验和白名单处理，以保证不被恶意代码注入。</li>
<li><code>【强制】</code>除非min API level &gt;= 17，请注意addJavascriptInterface的使用。</li>
</ul>
<blockquote>
<p>说明：API level &gt;= 17，允许js被调用的函数必须以@JavascripteInterface进行注解，因此不受影响；对于API level &lt; 17，尽量不要使用addJavascriptInterface，如果一定要用那么：1）使用https协议加载url，使用证书校验，防止访问的页面被篡改挂马；2）对加载URL做白名单过滤、完整性校验等防止访问的页面被篡改；3）如果加载本地html，应该会HTML内置在APK中，以及对HTML页面进行完整校验。</p>
</blockquote>
<ul>
<li><code>【强制】</code>使用Android的AES/DES/DESede加密算法时，不要使用默认的加密模式ECB，应显示指定使用CBC或CFB加密模式。<ul>
<li>ECB:Electronic codebook 电子密码本模式</li>
<li>CBC:Cipher-block chaning，密码分组链接模式</li>
<li>CFB:Cipher feedback，密文反馈模式</li>
<li>OFB:Output feedback,输出反馈模式</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明:加密模式ECB/CBC/CFB/OFB等，其中ECB的安全性较弱，会使相同的铭文在不同的时候产生相同的密文，容易遇到字典攻击，建议使用CBC或CFB模式。</p>
</blockquote>
<ul>
<li><code>【强制】</code>不要使用lookback 来通信敏感信息。</li>
<li><code>【推荐】</code>对于不需要使用File协议的应用，禁用File协议，显示设置webView.getSettings().setAllowFileAccess(false)，对于需要使用File协议的应用，禁止File协议调用JavaScript，显示设置webView.getSettings.setJavaScriptEnabled(false)。</li>
<li><code>【强制】</code>Android APP在HTTPS通信中，验证策略需要改成严格模式。</li>
</ul>
<blockquote>
<p>说明：Android App在https通信中，使用ALLOW_ALL_HOSTNAME_VERIFIER，表示允许和所有的HOST建立SSL通信，这会存在中间人攻击的风险，最终导致敏感信息可能会被劫持，以及其他形式的攻击。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">SSLSocketFactory sf = <span class="keyword">new</span> MySSLSocketyFactory(trustStore);</span><br><span class="line">sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);</span><br><span class="line"><span class="comment">//ALLOW_ALL_HOSTNAME_VERIFIER关闭host验证，允许和所有的host简历SSL通信，BROWSER_COMPATIBLE_HOSTNAME_VERIFIER和浏览器兼容的验证策略，即通配符能够匹配所有子域名，STRICT_HOSTNAME_VERIFIER严格匹配模式，hostname必须匹配第一个CN或者任何一个subject-alts，以上例子使用了ALLOW_ALL_HOSTNAME_VERIFIER，需要改成STRICT_HOSTNAME_VERIFIER。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>Android5.0以后安全性要求较高的应用应该使用window.setFlag(LayoutParam.FLAG_SECURE)禁止录屏。</li>
<li><code>【推荐】</code>zip中不建议允许<code>../../file</code>这样的路径，可能被篡改目录结构，造成供给。</li>
</ul>
<blockquote>
<p>说明：当zip压缩包中允许存在”…/“的字符串，攻击者可以利用多个”…/“在解压时改变zip文件存放的位置，当文件已经存在时就会进行覆盖，如果覆盖掉的文件时so/dex/odex文件，就有可能造成严重的安全问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="comment">//对路径进行判断，存在".."时抛出异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对重要的Zip压缩包文件进行数字签名校验，校验通过才进行解压</span></span><br><span class="line">String entryName = entry.getName();</span><br><span class="line"><span class="keyword">if</span>(entryName.contains(<span class="string">".."</span>))&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(unsecurity zipfile!);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>开放的activity/service/receiver等需要对传入的intent做合法性校验。</li>
<li><code>【推荐】</code>加密算法：使用不安全的Hash算法(MD5/SHA-1)加密信息，存在被破解的风险，建议使用SHA-256等安全性更高的Hash算法。</li>
<li><code>【推荐】</code>Android WebView组件加载网页发生证书认证错误时，采用默认的处理方法handler.cancel()，停止加载问题页面.</li>
</ul>
<blockquote>
<p>说明：Android WebView 组件加载网页发生证书认证错误时，会调用WebViewClient类的onReceivedSslError方法，如果该方法实现调用了handler.proceed()来忽略该证书错误，则会收到中间人攻击的威胁，可能导致隐私泄露。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">mWebView.addJavaScriptInterface(<span class="keyword">new</span> JsBridge(mContext),JS_OBJECT);</span><br><span class="line">mWebView.loadUrl(<span class="string">"http://www.example.com/test"</span>);</span><br><span class="line">mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedSslError</span><span class="params">(WebView view, SslErrorHandler handler, SslError error)</span></span>&#123;</span><br><span class="line">        handler.proceed();<span class="comment">//忽略SSL证书错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>直接传递命令或者间接处理有敏感信息或操作时，避免使用socket实现，使用能够控制权限校验身份的方式通讯</li>
</ul>
<h2 id="九-其他"><a href="#九-其他" class="headerlink" title="九 其他"></a>九 其他</h2><ul>
<li><code>【强制】</code>不要通过Msg传递大的对象，会导致内存问题。</li>
<li><code>【强制】</code>不能使用System.out.println打印log</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">Log.d(TAG,<span class="string">"Some Android Debug info..."</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">System.out.println(<span class="string">"System out println..."</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>Log的tag不能是<code>&quot; &quot;</code>。</li>
</ul>
<blockquote>
<p>说明：日志的tag是空字符串没有任何意义，也不利于过滤日志</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String TAG = <span class="string">"LoginActivity"</span>;</span><br><span class="line">Log.e(TAG,<span class="string">"Login failed!"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">Log.e(<span class="string">""</span>,<span class="string">"Login failed!"</span>);</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/13/《疯狂Android讲义》读书笔记（一）/" rel="next" title="《疯狂Android讲义》读书笔记（一）">
                <i class="fa fa-chevron-left"></i> 《疯狂Android讲义》读书笔记（一）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/03/我去2020/index/" rel="prev" title="我去2020">
                我去2020 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">老易</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yiguohan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/yiguohan" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yiguohan" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/519920207" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#说明"><span class="nav-number">1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编程规约"><span class="nav-number">2.</span> <span class="nav-text">编程规约</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命名风格"><span class="nav-number">2.1.</span> <span class="nav-text">命名风格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义常量"><span class="nav-number">2.2.</span> <span class="nav-text">定义常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码格式"><span class="nav-number">2.3.</span> <span class="nav-text">代码格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OOP规约"><span class="nav-number">2.4.</span> <span class="nav-text">OOP规约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合处理"><span class="nav-number">2.5.</span> <span class="nav-text">集合处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发处理"><span class="nav-number">2.6.</span> <span class="nav-text">并发处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制语句"><span class="nav-number">2.7.</span> <span class="nav-text">控制语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注释"><span class="nav-number">2.8.</span> <span class="nav-text">注释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android资源文件命名与使用"><span class="nav-number">3.</span> <span class="nav-text">Android资源文件命名与使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android基本组件"><span class="nav-number">4.</span> <span class="nav-text">Android基本组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UI与布局"><span class="nav-number">5.</span> <span class="nav-text">UI与布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-进程、线程与消息通信"><span class="nav-number">6.</span> <span class="nav-text">五 进程、线程与消息通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六-文件与数据库"><span class="nav-number">7.</span> <span class="nav-text">六 文件与数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七-Bitmap-Drawable与动画"><span class="nav-number">8.</span> <span class="nav-text">七 Bitmap/Drawable与动画</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八-安全"><span class="nav-number">9.</span> <span class="nav-text">八 安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九-其他"><span class="nav-number">10.</span> <span class="nav-text">九 其他</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">老易</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        




  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=65215428";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: '1523355396000', 
            owner: 'yiguohan',
            repo: 'yiguohan.github.io',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: 'f12aa205b4be0d0234462686269f2a1ca2d0e324',
            
                client_id: 'a26bc09f631622a6c4dc'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  





  

  

  

  
  

  

  

  

</body>
</html>
