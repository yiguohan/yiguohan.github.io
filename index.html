<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="老易的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="老易的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老易的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>老易的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">老易的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">大口吃瓜 快意飞马</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/03/我去2020/index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老易的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/03/我去2020/index/" itemprop="url">我去2020</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-03T10:41:18+08:00">
                2020-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转眼就2020年了 我来博客挖坟了。</p>
<p>在刚刚过去的2019年，是我告诉成长的一年。积极努力准备面试，像一颗海绵，不断吸取各种各样的知识。拿到过Offer，也遭遇过大厂面试失败。虽然没有达到目标，但总体来说非常精彩，而且让我觉得每一步都是有意义的。</p>
<p>对于每个人来说，学习是终生的。而对于我来说在2019年最大的收获其实莫过于学习了一些如何学习的方法。在离开了学校，缺乏老师的面授与答疑，完全靠自己的情况下，如何保证持续高效的学习是一件非常重要的事情。在没有教科书，如何在海量的互联网世界里筛选正确且高效的信息也是一个很大的难题。</p>
<p>输出是学习程度的唯一检验标准。各种各样的输出模式，如博客文章、分享演讲以及小黄鸭学习法都是有效的，在输出信息的时候大脑在不断理清思路寻找逻辑自洽，这是一个非常有效的过程。很多人都有这样的体验，在看某个概念相关的文章的当下觉得自己“嗯，了解了，问题不大”，可是转眼就忘得一干二净。其实这是一种错觉，你以为你知道了，其实不然，你只是当下理解了而已，并没有把它变成自己的东西，它还留在纸上屏幕上。而当你可以给他人完整描述这一概念，并能自如应对倾听者的各种相关提问的时候，你才能说你基本了解了。举个例子，我曾在公司做了一场关于“编码加密以及HTTPS”相关概念的分享，尽管在分享前我大量查阅资料，不断完善Presentation的细节，依然避免不了在Q&amp;A环节被台下的听众问到蒙圈的情况。同样的，我一直在反思，为什么原理我都了解，在面试回答的时候总是不能给出满意的答案，于是我在家里模拟“面试官的口吻”问自己相关问题，真的在回答的时候磕磕绊绊，支支吾吾，说实话，要我是面试官也不会录取自己。</p>
<p>以上大概就是我在新的一年想要立下每周一篇博客的Flag的动机吧！（动什么？）以输出倒逼输入，检验自己是否真的了解，这样才能做到不自欺欺人。</p>
<p>新的一年，新的Flag。希望我能够坚持下去。</p>
<p>​                                                                                                                                                                            老易</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/10/Android开发规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老易的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/Android开发规范/" itemprop="url">Android开发规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T18:16:36+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本手册以开发者为中心视角分为Java语言规范，Android资源文件命名与使用，Android基本组件，UI与布局，进程、线程与消息通信，文件与数据库，Bitmap、Drawable与动画，安全，其他等就大部分，根据约束力强弱，规约依次分为强制、推荐、参考三大类：</p>
<ul>
<li><code>【强制】</code>必须遵守，违反本约定或将会引起严重的后果；</li>
<li><code>【推荐】</code>尽量遵守，长期遵守有助于系统稳定性和合作效率的提升；</li>
<li><code>【参考】</code>充分理解，技术意识的引导，是个人学习、团队沟通、项目合作的方向</li>
</ul>
<p>对于文档中的相关拓展信息，<code>说明</code>对内容作了适当扩展和解释；<code>正例</code>提倡具体的编码和实现方式；<code>反例</code>说明需要提防的雷区，以及错误案例。</p>
<h2 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><ul>
<li><code>【强制】</code>代码中的命名均不能以下划线或美元符号开始，也不能以下划线与美元符号结束。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">_name/__name/$name/name_/name$/name_</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</li>
</ul>
<blockquote>
<p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免其一。注意，及时纯拼音命名方式也要避免采用</p>
</blockquote>
<ul>
<li><code>【强制】</code>类名使用UpperCamelCase风格</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">MarcoPolo/UserDO/XmlService/</span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line">macroPolo/UserDo/XMLService/</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">localValue/getHttpMessage()/inputUserId</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>常量命名全部大写，单词之间用下划线隔开，力求予以表达完整清楚，不要嫌名字长</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">MAX_STOCK_COUNT</span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line">MAX_COUNT</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类名开始，以Test结尾。</li>
<li><code>【强制】</code>类型与中括号紧挨相连来定义数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：定义整形数组</span></span><br><span class="line"><span class="keyword">int</span>[] arrayDemo</span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line">String args[]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>POJO类中布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列化错误。</li>
<li><code>【强制】</code>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：应用工具类包名为com.partner.example.util，类名为MessageUtils（此规则参考spring的框架结构）</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>杜绝完全不规范的缩写，避免望文不知义。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成condi，此类随意缩写严重降低了代码的可阅读性。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>为了达到代码自解释的目标，任何自定义变成元素在命名时，使用尽量完整的单词组合来表达其意。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正例：从远程仓库拉取代码的类命名为PullCodeFromRemoteRepository。</span><br><span class="line">反例：变量<span class="keyword">int</span> a；的随意命名方式。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。</li>
</ul>
<blockquote>
<p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFactory</span></span>; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginProxy</span></span>; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceObserver</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>接口类中的方法和属性不要加任何修饰符号（public也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="comment">//接口方法签名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="comment">//接口基础常量</span></span><br><span class="line">String COMPANY = “partner”；</span><br><span class="line"></span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="comment">//接口方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">( )</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。</p>
</blockquote>
<ul>
<li><code>【推荐】</code>形容能力的接口名称，去对应的形容词为接口名（通常是-able的形式）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">AbstractTranslator实现Translatable</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【参考】</code>枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。</li>
</ul>
<blockquote>
<p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS/UNKNOWN_REASON</span><br></pre></td></tr></table></figure>
<h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><ul>
<li><code>【强制】</code>不允许任何魔法值（即未预先定义的常量）直接出现在代码中。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">String key = “Id#partner_”+ tradeId; cache.put(key,value);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>long或者Long初始赋值时，使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。</li>
</ul>
<blockquote>
<p>说明：Long a = 2l；写的是数字21还是Long型的2？</p>
</blockquote>
<ul>
<li><code>【推荐】</code>不要使用一个常量类维护所有常量，按常量功能进行分类，分开维护。</li>
</ul>
<blockquote>
<p>说明：大而全的常量类，飞的使用查找功能才能定位到修改的常量，不利于理解和维护。</p>
</blockquote>
<ul>
<li><code>【推荐】</code>常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。<ul>
<li>跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下</li>
<li>应用内共享常量：防止在一方库中，通常是子模块中的constant目录下</li>
<li>子工程内部共享常量：即在当前子工程的constant目录下。</li>
<li>包内共享常量：即在当前包下单独的constant目录下。</li>
<li>类内共享常量：直接在类内部private static final定义。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：易懂变量也要统一定义成应用内共享常量，两位工程师在两个类中分别定义了表示“是”的变量：</span></span><br><span class="line"><span class="comment">//类A中：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YES = “yes”;</span><br><span class="line"><span class="comment">//类B中：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YES = “y”;</span><br><span class="line">A.YES.equals(B.YES)，预期是<span class="keyword">true</span>，但时机返回为<span class="keyword">false</span>，导致线上问题。</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>如果变量值尽在一个固定范围内变化用enum类型来定义</li>
</ul>
<blockquote>
<p>说明：如果存在名称之外的延伸属性使用enum类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> SeasonEnum&#123;</span><br><span class="line">        SPRING(<span class="number">1</span>)，SUMMER(<span class="number">2</span>)，AUTUMN(<span class="number">3</span>)，WINTER(<span class="number">4</span>);</span><br><span class="line">        Int seq;</span><br><span class="line">        SeasonEnum(<span class="keyword">int</span> seq)&#123;</span><br><span class="line">            <span class="keyword">this</span>.seq = seq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><ul>
<li><code>【强制】</code>大括号的使用约定。如果是大括号内为空，则简洁地写成{ }即可，不需要换行；如果是非空代码块则：<ul>
<li>左大括号前不换行；</li>
<li>做大括号后换行；</li>
<li>右大括号前换行；</li>
<li>右大括号后还有else等代码则不换行；表示终止的右大括号必须换行。</li>
</ul>
</li>
<li><code>【强制】</code>左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：<span class="keyword">if</span>(空格a == b空格)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>if/for/while/switch/do等保留字与括号之间都必须加空格。</li>
<li><code>【强制】</code>任何二目、三目运算符的左右两边都需要加一个空格。</li>
</ul>
<blockquote>
<p>说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</p>
</blockquote>
<ul>
<li><code>【强制】</code>采用4个空格缩进，禁止使用tab字符、</li>
</ul>
<blockquote>
<p>说明：如果是用tab缩进，必须设置1个tab为4个空格。Android Studio设置tab为4个空格时，请勿勾选Use tab character。</p>
</blockquote>
<ul>
<li><code>【强制】</code>注释的双鞋县与注释内容之间有且仅有一个空格。</li>
<li><code>【强制】</code>单行字符数限制不超过120个，超出需要换行，换行时遵循如下规则：<ul>
<li>第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进，参考示例。</li>
<li>运算符与下文一起换行。</li>
<li>方法调用的点符号与下文一起换行。</li>
<li>方法调用时，多个参数，需要换行时，在逗号后进行。</li>
<li>在括号前不需要换行，见反例。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 超过120个字符的情况下，换行缩进4个空格，点号和方法名一起换行</span></span><br><span class="line">sb.append(“zi”).append(“xin”)...</span><br><span class="line">    .append(“huang”)...</span><br><span class="line">    .append(“huang”)...</span><br><span class="line">    .append(“huang”);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 超过120个字符的情况下，不要在括号前换行</span></span><br><span class="line">sb.append(<span class="string">"zi"</span>).append(<span class="string">"xin"</span>)...append</span><br><span class="line">(<span class="string">"huang"</span>);</span><br><span class="line"><span class="comment">// 参数很多的方法调用可能超过120个字符，不要在逗号前换行</span></span><br><span class="line">method(arg1, args2, args3,…</span><br><span class="line">    , argsx)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>方法参数在定义和传入时，多个参数都好后边必须加空格。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：下例中实参的“a”，后边必须要有一个空格。</span></span><br><span class="line">method(“a”，“b”，“c”)；</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>IDE的text file encoding 设置为UTF-8; IDE文件的换行符使用Unix格式，不要使用Windows格式。</li>
<li><code>【强制】</code>没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。</li>
<li><code>【强制】</code>不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。</li>
</ul>
<h3 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h3><ul>
<li><code>【强制】</code>避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析的成本，直接用类名访问即可。</li>
<li><code>【强制】</code>相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。</li>
</ul>
<blockquote>
<p>说明：可变参数必须放置在参数列表的最后。（提议尽量避免使用可变参数编程）</p>
</blockquote>
<ul>
<li><code>【强制】</code>外部正在调用或者第二方库依赖的接口，不允许修改方法名，避免对接口调用方产生影响。结构过时必须加@Deprecated注解，并清晰地说明采用的新接口是什么。</li>
<li><code>【强制】</code>不能使用过时的类或方法</li>
<li><code>【强制】</code>Object的equals方法容易抛空指针异常，应使用常量或者确定有值的对象来调用equals。</li>
</ul>
<blockquote>
<p>说明：推荐使用java.util.Objects#equals（JDK7引入的工具类）</p>
</blockquote>
<ul>
<li><code>【强制】</code>所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。</li>
</ul>
<blockquote>
<p>说明：对于 Integer var = ? 在-128至127范围内的复制，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer只可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。</p>
</blockquote>
<ul>
<li>关于基本数据类型与包装数据类型的使用标准如下：<ul>
<li><code>【强制】</code>所有的POJO类属性必须使用包装数据类型。</li>
<li><code>【强制】</code>RPC方法的返回值和参数必须使用包装数据类型。</li>
<li><code>【推荐】</code>所有的局部变量使用基本数据类型</li>
</ul>
</li>
<li><code>【强制】</code>序列化类新增属性时，不要修改serialVersionUID字段，避免反序列化失败。</li>
<li><code>【强制】</code>构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。</li>
<li><code>【强制】</code>使用当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。</li>
<li><code>【强制】</code>类内方法定义的顺序依次是：共有方法或保护方法&gt;私有方法&gt;getter/setter方法。</li>
</ul>
<blockquote>
<p>说明：共有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低。</p>
</blockquote>
<ul>
<li><code>【强制】</code>setter方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter方法中，不要增加业务逻辑，增加排查问题的难度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line">    <span class="function">Public Integer <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        If(condition)&#123;</span><br><span class="line">            Return <span class="keyword">this</span>.data+<span class="number">100</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Return <span class="keyword">this</span>.data-<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。</li>
</ul>
<blockquote>
<p>说明：反编译出的自己吗文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">    String str = “start”；</span><br><span class="line">    or(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        str = str + “hello”;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>final可以声明类、成员变量、方法以及本地变量，下列情况下使用final关键字：<ul>
<li>不允许被继承的类，如：String类。</li>
<li>不允许被重写的方法。</li>
<li>不允许运行过程中重新赋值的局部变量。</li>
<li>避免上下文重复使用一个变量，使用final描述可以强制重新定义一个变量，方便更好地进行重构。</li>
</ul>
</li>
<li><code>【推荐】</code>慎用Object的clone方法来拷贝对象。</li>
</ul>
<blockquote>
<p>说明：对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现属性对象的拷贝。</p>
</blockquote>
<ul>
<li><p><code>【推荐】</code>类成员与方法访问控制从严：</p>
<ul>
<li>如果不允许外部直接通过new来创建对象，那么构造方法必须是private</li>
<li>工具类不允许有public或default构造方法</li>
<li>类非static成员变量并且与子类共享，必须是protected。</li>
<li>类非static成员变量并且仅在本类使用，必须是private。</li>
<li>类static成员变量如果仅在本类使用，必须是private。</li>
<li>若是stattic成员变量，必须考虑是否为final。</li>
<li>类成员方法只供内部调用，必须是private。</li>
<li>类成员方法只对继承类公开，那么限制为protected。</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。<br>思考：如果是一个private方法，想删除就删除，可是一个public的方法或成员变量，在删除之前如果不find usage一下，很难确定它是否在其他地方有引用。变量和方法像自己的小孩，尽量让它在自己的视线范围内，作用域太大，无限制的到处跑会让人担心。</p>
</blockquote>
<h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><ul>
<li><code>【强制】</code>关于hashCode和equals的处理，遵循如下规则<ul>
<li>只要重写equals，就必须重写hashCode。</li>
<li>因为Set储存的是不重复对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。</li>
<li>如果自定义对象作为Map的键，那么必须重写hashCode和equals。</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：String 重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。</p>
</blockquote>
<ul>
<li><code>【强制】</code>ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException。</li>
</ul>
<blockquote>
<p>说明：subList返回的是ArrayList的内部类SubList，并不是ArrayList，而是ArrayList的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。</p>
</blockquote>
<ul>
<li><p><code>【强制】</code>在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException。</p>
</li>
<li><p><code>【强制】</code>使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的类型完全一样的数组，大小就是list.size()。</p>
</li>
</ul>
<blockquote>
<p>说明：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为[list.size()]的数组元素将被置为null，其他数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。</p>
</blockquote>
<ul>
<li><code>【强制】</code>使用工具类Array.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException。</li>
</ul>
<blockquote>
<p>说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p>
</blockquote>
<ul>
<li><code>【强制】</code>泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用add方法，而&lt;? super T&gt;不能使用get方法，作为借口调用赋值时易出错。</li>
</ul>
<blockquote>
<p>说明：扩展说一下PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt;。</p>
</blockquote>
<ul>
<li><code>【强制】</code>不要在foreach循环里进行remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要Iterator对象加锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">While(iterator.hasNext())&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反例：</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(“<span class="number">1</span>”);</span><br><span class="line">list.add(“<span class="number">2</span>”)</span><br><span class="line"><span class="keyword">for</span>(String item:list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(“<span class="number">1</span>”.equals(item))&#123;</span><br><span class="line">        list.remove(item);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？</p>
</blockquote>
<ul>
<li><code>【推荐】</code>集合初始化需指定集合的大小</li>
</ul>
<blockquote>
<p>说明：HashMap使用HashMap(int initialCapacity)初始化</p>
</blockquote>
<ul>
<li><code>【推荐】</code>使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历</li>
</ul>
<blockquote>
<p>说明：keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。</p>
</blockquote>
<h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><ul>
<li><code>【推荐】</code>获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</li>
<li><code>【推荐】</code>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</li>
<li><code>【推荐】</code>县城资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li>
</ul>
<blockquote>
<p>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</blockquote>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><ul>
<li><p><code>【推荐】</code>在一个switch块内，每个case要么通过break/return等来中止，要么注释说明程序将继续执行到哪个case为止；在一个switch块内必须包含default语句并且放在最后，即使空代码。</p>
</li>
<li><p><code>【推荐】</code>在if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式。</p>
</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li><code>【推荐】</code>类、类属性、类方法的注释必须使用Javadoc规范，使用<code>/**内容*/</code>格式，不得使用<code>// xxx</code>方式。</li>
</ul>
<p>说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p>
<ul>
<li><code>【推荐】</code>所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</li>
</ul>
<p>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p>
<ul>
<li><code>【推荐】</code>所有的类都必须添加创建者和创建日期。</li>
<li><code>【推荐】</code>方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/<em> </em>/注释，注意与代码对齐。</li>
<li><code>【推荐】</code>代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</li>
<li><code>【推荐】</code>谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。</li>
</ul>
<blockquote>
<p>说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p>
</blockquote>
<ul>
<li><code>【推荐】</code>特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<ul>
<li>待办事宜（TODO）:（标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。</li>
</ul>
</li>
<li><code>【推荐】</code>错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。</li>
</ul>
<h2 id="Android资源文件命名与使用"><a href="#Android资源文件命名与使用" class="headerlink" title="Android资源文件命名与使用"></a>Android资源文件命名与使用</h2><ul>
<li><code>【推荐】</code>资源文件需带模块前缀。</li>
<li><code>【推荐】</code>layout文件的命名方式<ul>
<li>Activity的layout以module_activity开头</li>
<li>Fragment的layout以module_fragment开头</li>
<li>Dialog的layout以module_dialog开头</li>
<li>Include的layout以module_include开头</li>
<li>ListView的item layout以module_list_item开头</li>
<li>RecyclerView的item layout以module_recyle_item开头</li>
<li>GridView的item layout以module_grid_item开头</li>
</ul>
</li>
<li><code>【推荐】</code>drawable资源名称以小写单词+下划线的方式命名，根据分辨率不同放在不同的drawable目录下，建议只使用一套，例如：drawable_xhdpi。采用规则如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模块名_业务功能描述_控件描述_控件状态限定词</span><br><span class="line">module_login_btn_pressed</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>anim资源名称以小写单词+下划线的方式命名，采用以下规则：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模块名_逻辑名称_[方向|序号]</span><br><span class="line">tween 动画资源：尽可能以通用的动画名称命名，如：module_fade_in,module_fade_out,module_push_down_in;</span><br><span class="line">frame 动画资源：尽可能以模块+功能命名+序号。如：module_loading_gray_001</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>color资源使用#AARRGGBB，写入module_colors.xml文件中，命名格式采用以下规则：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//模块名_逻辑名称_颜色,如：</span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">“module_btn_bg_color”</span>&gt;</span>#33b5e5e5<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>dimen资源以小写单词+下划线方式命名，写入module_dimens.xml文件中，采用以下规则：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名_描述信息</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>style资源采用小写单词+下划线方式命名，写入module_styles.xml文件中，采用以下规则：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父style名称.当前style名称</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>string资源文件或者文本用到字符需要全部写入module_string.xml文件中，字符串以小写单词+下划线的方式命名，采用以下规则：模块名_逻辑名称</li>
<li><code>【推荐】</code>Id资源原则上以驼峰法命名，View组件的资源id需要以View的缩写作为前缀。</li>
</ul>
<table>
<thead>
<tr>
<th>控件</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>LinearLayout</td>
<td>ll</td>
</tr>
<tr>
<td>RelativeLayout</td>
<td>rl</td>
</tr>
<tr>
<td>ConstrantLayout</td>
<td>cl</td>
</tr>
<tr>
<td>ListView</td>
<td>lv</td>
</tr>
<tr>
<td>ScrollView</td>
<td>sv</td>
</tr>
<tr>
<td>TextView</td>
<td>tv</td>
</tr>
<tr>
<td>Button</td>
<td>btn</td>
</tr>
<tr>
<td>ImageView</td>
<td>iv</td>
</tr>
<tr>
<td>CheckBox</td>
<td>cb</td>
</tr>
<tr>
<td>RadioButton</td>
<td>rb</td>
</tr>
<tr>
<td>EditText</td>
<td>et</td>
</tr>
</tbody>
</table>
<ul>
<li><code>【推荐】</code>大分辨率图片（单维度超过1000）大分辨率图片建议统一放在xxhdpi目录下管理，否则会导致占用内存成倍数增加</li>
</ul>
<h2 id="Android基本组件"><a href="#Android基本组件" class="headerlink" title="Android基本组件"></a>Android基本组件</h2><blockquote>
<p>Android基本组件指Activity/Fragment/Service/BroadcastReceiver/ContentProvider等</p>
</blockquote>
<ul>
<li><code>【强制】</code>Activity间的数据通信，对于数据量比较大的，避免使用Intent+Parceable的方式，可以考虑EventBus等替代方案，以免造成TransactionTooLargeException.</li>
<li><code>【强制】</code>Activity#onSaveInstanceState()方法不是Activity生命周期方法，也不保证一定会被调用。它是用来在Activity被意外销毁时保存UI状态的，只能用于保存临时性数据，例如UI控件的属性等，不能跟数据的持久化存储混为一谈。持久化存储应该在Activity#onPause()/onStop()中实行。</li>
<li><code>【强制】</code>Activity间通过隐式Intent的跳转，在发出Intent之前必须通过resolveActivity检查，避免找不到合适的调用组件，造成ActivityNotFoundException的异常。</li>
<li><code>【强制】</code>避免在Service#onStartCommand()/onBind()方法中执行耗时操作，如果确有需求，应改用IntentService或采用其他异步机制完成。</li>
<li><code>【强制】</code>避免在BroadcastReceiver#onReceive()中执行耗时操作，如果有耗时工作，应该创建IntentService完成，而不应该在BroadcastReceiver内创建子线程去做。</li>
</ul>
<blockquote>
<p>说明：由于该方法是在主线程执行，如果执行耗时操作时操作会导致UI不流畅，可以使用IntentService，创建HandlerThread或者调用Context#registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)方法等方式，在其他Worker线程执行onReceive方法。BroadcastReceiver#onReceive()方法耗时超过10秒钟，可能会被系统杀死。</p>
</blockquote>
<p>参考：<a href="https://developer.android.com/reference/android/content/BroadcastReceiver.html#onReceive" target="_blank" rel="noopener">https://developer.android.com/reference/android/content/BroadcastReceiver.html#onReceive</a></p>
<ul>
<li><code>【强制】</code>避免使用隐式Intent广播敏感信息，信息可能被其他注册了对应BroadcastReceiver的App接收</li>
</ul>
<blockquote>
<p>说明：通过Context#sendBroadcast()发送的隐式广播会被所有感兴趣的receiver接收，恶意应用注册监听该广播的receiver可能会获取到Intent中传递的敏感信息，并进行其他为先操作。如果发送的广播为使用Context#sendOrderdBroadcast()方法发送的有序广播，优先级较高的恶意Receiver可能直接丢弃该广播，造成服务不可用，或者向广播结果塞入恶意数据。如果广播仅限于应用内，则可以使用LocalBroadcastManager#sendBroadcast()实现，避免敏感信息外泄和Intent拦截风险。</p>
</blockquote>
<ul>
<li><code>【推荐】</code>添加Fragment时，确保FragmentTransaction#commit()在Activity#onPostResume()或者FragmentActivity#onResumeFragments()内调用。不要随意使用FragmentTransaction#commitAlloingStateLoss()来代替。</li>
</ul>
<blockquote>
<p>说明：Activity可能因为各种原因被销毁，Android支持页面被销毁前通过Activity#onSaveInstanceState()保存自己的状态。但如果FragmentTransaction.commit()发生在Activity状态保存之后，就会导致Activity重建、恢复状态时无法还原页面状态，从而可能出错。为避免给用户造成不好的体验，系统会抛出IllegalStateExceptionStateLoss异常。推荐的做法是在Activity的onPostResume()或onResumeFragments()里执行FragmentTransaction.commit()，如有必要也可在onCreate()里执行。不要随意改用FragmentTransaction.commitAllowingStateLoss()或者直接使用try-catch避免crash，这不是问题的根本解决之道，当且仅当你确认Activity重建、恢复状态时，本次commit丢失不会造成影响时才可这么做。</p>
</blockquote>
<p>参考：</p>
<p><a href="https://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html" target="_blank" rel="noopener">https://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html</a><br><a href="https://developer.android.com/reference/android/app/FragmentTransaction.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/FragmentTransaction.html</a></p>
<ul>
<li><code>【推荐】</code>不要在Activity#onDestroy()内执行释放资源的工作，例如一些工作线程的销毁和停止，因为onDestroy()执行的时机可能较晚。可根据实际需要，在Activity#onPause()/onStop()中结合isFinishing()</li>
<li><code>【推荐】</code>如非必须，避免使用嵌套的Fragment。</li>
</ul>
<blockquote>
<p>说明：嵌套Fragment是在Android API 17添加到SDK以及Support库中的功能，Fragment嵌套使用会有一些坑，容易出现bug，比较常见的问题有如下几种：1) onActivityResult()方法的处理错乱，内嵌的Fragment可能收不到该方法的回调，需要由宿主Fragment进行转发处理；2) 突变动画效果；3) 被继承的setRetainInstance()，导致在Fragment重建时多次触发不必要的逻辑。</p>
</blockquote>
<p>非必须的场景尽可能避免使用嵌套Fragment，如需使用请注意上述问题。</p>
<ul>
<li><code>【推荐】</code>总是使用显式Intent启动或者绑定Service，且不要为服务声明IntentFilter，保证应用的安全性。如果确实需要使用隐式调用，则可为Service提供IntentFilter并从Intent中排出相应的组件名称，但必须打牌使用Intent#setPackage()方法设置Intent的指定包名，这样可以充分消除目标服务的不确定性。</li>
<li><code>【推荐】</code>Service需要以多线程来兵法处理多个启动请求，建议使用IntentService，可避免各种复杂的设置。</li>
</ul>
<blockquote>
<p>说明：Service组件一般运行主线程，应当避免耗时操作，如果有耗时操作应该在Worker线程执行。可以使用IntentService执行后台任务。<br>扩展参考：<a href="https://developer.android.com/guide/components/services.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/services.html</a></p>
</blockquote>
<ul>
<li><code>【推荐】</code>对于只用于应用内的广播，优先使用LocalBroadcastManager来进行注册和发送，LocalBroadcastManager安全性更好，同时拥有更高的运行效率。</li>
</ul>
<blockquote>
<p>说明：对于使用Context#sendBroadcast()等方法发送全局广播的代码进行提示。如果该广播仅用于应用内，则可以使用LocalBroadcastManager来避免广播泄露以及广播被拦截等安全问题，同时相对全局广播本地广播的更高效。</p>
</blockquote>
<ul>
<li><code>【推荐】</code>当前Activity的onPause方法执行结束后才会执行下一个Activity的onCreate方法，所以在onPause方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效率。</li>
<li><code>【强制】</code>不要在Android的Application对象中缓存数据。基础组件之间的数据共享请使用Intent等机制，也可使用SharedPreferences等数据持久化机制。</li>
<li><code>【推荐】</code>使用Toast时，建议定义一个全局的Toast对象，这样可以避免连续显示Toast时不能取消上一次Toast消息的情况（如果你有连续弹出Toast的情况，避免使用Toast.makeText）。</li>
<li><code>【推荐】</code>使用Adapter的时候，如果使用了ViewHolder做缓存，在getView()方法中无论这项convertView的每个子控件是否需要设置属性（比如某个Text设置的文本可能为null，某个按钮的背景色为透明，某控件的颜色为透明等），都需要为其显式设置属性（TextView的文本为空也需要设置setText(“”),透明背景也需要设置），否则在滑动的过程中，因为adapter item复用的原因，会出现内容的显示错乱。</li>
<li><code>【推荐】</code>Activity或者Fragment中动态注册BroadcastReceiver时，registerReceiver()和unregisterReceiver要成对出现。</li>
</ul>
<blockquote>
<p>说明：如果registerReceiver()和unregisterReceiver()不成对出现，则可能导致已经注册的receiver没有在合适的时机注销，导致内存泄漏，占用内存空间，加重SystemService负担。部分华为的机型会对receiver进行资源管控，单个应用注册过多receiver会触发管控模块抛出异常。Activity的生命周期不对应，可能出现多次onResume造成receiver注册多个，但最终只注销一个，其余receiver产生内存泄漏。</p>
</blockquote>
<h2 id="UI与布局"><a href="#UI与布局" class="headerlink" title="UI与布局"></a>UI与布局</h2><ul>
<li><code>【强制】</code>布局中不得不使用ViewGroup多重嵌套，不要使用LinearLayout，改用RelativeLayout，可以有效降低嵌套数。</li>
</ul>
<blockquote>
<p>说明：Android应用页面上任何一个View都需要经过measure/layout/draw三个步骤才能被正确渲染。从xml layout的顶部节点开始进行measure，每个子节点都需要向自己的父节点提供自己的尺寸来决定展示的位置，在此过程中可能还会重新measure（由此可能导致measure的时间消耗为原来的2-3倍）。节点所处位置越深，嵌套带来的measure越多，计算就会越费时。这就是为什么扁平的View结构会性能更好。同时，页面上的View越多，measure/layout/draw所花费的时间就越久。要缩短这个时间，关键是保持View的属性结构尽量扁平，而且要移除所有不需要渲染的View。理想情况下，总共的measure/layout/draw时间应该被很好的控制在16ms以内，以保证滑动屏幕时UI的流畅。要找到那些多余的View（增加渲染延迟的view）,可以用Android Studio Monitor里的Hierarachy Viewer工具，可视化的查看所有的View。</p>
</blockquote>
<p>扩展参考：</p>
<p><a href="https://developer.android.com/studio/profile/hierarchy-viewer.html" target="_blank" rel="noopener">https://developer.android.com/studio/profile/hierarchy-viewer.html</a></p>
<p><a href="http://mrpeak.cn/android/2016/01/11/android-performance-ui" target="_blank" rel="noopener">http://mrpeak.cn/android/2016/01/11/android-performance-ui</a></p>
<p><a href="https://www.safaribooksonline.com/library/view/high-performance-android/9781491913994/ch04.html#figure-story_tree" target="_blank" rel="noopener">https://www.safaribooksonline.com/library/view/high-performance-android/9781491913994/ch04.html#figure-story_tree</a></p>
<ul>
<li><code>【推荐】</code>在Activity中显示对话框或弹出浮层时，尽量使用DialogFragment，而非Dialog/AlertDialog，这样便于随Activity生命周期管理对话框/弹出浮层的生命周期。</li>
<li><code>【推荐】</code>源文件统一采用UTF-8的形式进行编码。</li>
<li><code>【强制】</code>禁止在非ui线程进行view相关操作。</li>
<li><code>【推荐】</code>文本大小使用单位dp，view大小使用单位dp。对于Textview，如果在文字大小确定的情况下推荐使用wrap_content布局避免出现文字显示不全的适配问题。</li>
<li><code>【强制】</code>禁止在设计布局时设置子view和父view中为同样的背景造成页面过度绘制，推荐将不需要显示的布局进行及时隐藏。</li>
<li><code>【推荐】</code>灵活使用布局，推荐使用Merge/ViewStub来优化布局，尽可能多的减少UI布局层级，推荐使用FrameLayout,LinearLayout、RelativeLayout次之。</li>
<li><code>【推荐】</code>在需要时刻刷新某一区域的组件时，建议通过以下方式避免引发全局layout刷新：<ul>
<li>设置固定的view大小的高宽，如倒计时组件等；</li>
<li>调用view的layout方式修改位置，如弹幕组件等；</li>
<li>通过修改canvas位置并且调用invalidate(int i,int t,int r,int b)等方式先定刷新区域；</li>
<li>通过设置一个是否允许requestLayout的变量，然后重写控件的requestlayout/onSizeChanged方法，判断控件的大小没有改变的情况下，当进入requestLayout的时候，直接返回而不调用super的requestLayout方法。</li>
</ul>
</li>
</ul>
<p>生命周期管理对话框/弹出浮层的生命周期。</p>
<ul>
<li><p><code>【推荐】</code>不能在Activity没有完全显示时显示PopWindow和Dialog。生命周期管理对话框/弹出浮层的生命周期。</p>
</li>
<li><p><code>【推荐】</code>尽量不要使用AnimationDrawable，它在初始化的时候就将所有图片加载到内存中，特别占内存，并且还不能释放，释放之后下次进入再次加载时会报错。</p>
</li>
</ul>
<blockquote>
<p>说明：Android的帧动画可以使用AnimationDrawable实现，但是如果你的帧动画中包含过多帧图片，一次性加载所有帧图片所导致的内存消耗会使低端机发生OOM异常。帧动画所使用的图片要注意降低内存消耗，当图片比较大时，容易出现OOM。</p>
</blockquote>
<p>参考：</p>
<p><a href="https://stackoverflow.com/questions/8692328/causing-outofmemoryerror-in-frame-by-frame-animation-in-android" target="_blank" rel="noopener">https://stackoverflow.com/questions/8692328/causing-outofmemoryerror-in-frame-by-frame-animation-in-android</a></p>
<p><a href="https://blog.csdn.net/wanmeilang123/article/details/53929484" target="_blank" rel="noopener">https://blog.csdn.net/wanmeilang123/article/details/53929484</a></p>
<p><a href="https://segmentfault.com/a/1190000005987659" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005987659</a></p>
<p><a href="https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html</a></p>
<ul>
<li><code>【强制】</code>不能使用ScrollView包裹ListView/GridView/ExpandableListView；因为这样会把ListView的所有Item都加载到内存中，要消耗巨大的内存和cpu去绘制页面。</li>
</ul>
<blockquote>
<p>说明：ScrollView中嵌套List或RecyclerView的做法官方明确禁止。除了开发过程中遇到的各种视觉和交互问题，这种做法对性能也有较大损耗。ListView等UI组件自身有垂直滚动功能，也没有必要在嵌套一层ScrollView。目前为了较好的UI体验，更贴近Material Design的设计，推荐使用NestedScrollView。</p>
</blockquote>
<p>参考:</p>
<p><a href="https://developer.android.com/reference/android/widget/ScrollView.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/widget/ScrollView.html</a></p>
<p><a href="https://developer.android.com/reference/android/support/v4/widget/NestedScrollView.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/support/v4/widget/NestedScrollView.html</a></p>
<h2 id="五-进程、线程与消息通信"><a href="#五-进程、线程与消息通信" class="headerlink" title="五 进程、线程与消息通信"></a>五 进程、线程与消息通信</h2><ul>
<li><code>【强制】</code> 不要通过Intent在Android基础组件之间传递大数据(binder transaction缓存为 1MB)，可能导致OOM。</li>
<li><code>【强制】</code> 在Applicaiton的业务初始化代码加入进程判断，确保只在自己需要的进程初始化。特别是后台进程减少不必要的业务初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationextends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function">pulic <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//在所有进程中初始化</span></span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">//仅在主进程中初始化</span></span><br><span class="line">       <span class="keyword">if</span>(mainProcess)&#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//仅在后台进程中初始化</span></span><br><span class="line">       <span class="keyword">if</span>(bgProcess)&#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code> 新建线程时，必须通过线程池提供（AsyncTask或者ThreadPoolExecutor或者其他形式自定义的线程池），不允许在应用中自行显式创建线程。</li>
</ul>
<blockquote>
<p>说明：使用线程池的好处是在减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能在成系统创建大量同类的线程而导致消耗完内存或者“过度切换”的问题。另外创建匿名线程不便于后续的资源使用分析，对性能分析会造成困扰。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> NUMBER_OF_CORES = Runtime.getRuntime().avilableProcessors();</span><br><span class="line"><span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">1</span>;</span><br><span class="line">TimeUnit KEEP_ALIVE_TIME_UNIT = TimeUnit.SECONDS;</span><br><span class="line">BlockQueue&lt;Runnable&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(NUMBER_OF_CORES, NUMBER_OF_CORES*<span class="number">2</span>, KEEP_ALIVE_TIME, KEEP_ALIVE_TIME_UNIT, taskQueue, <span class="keyword">new</span> BackgroundThreadFactory(), <span class="keyword">new</span> DefaultRejectedExecutionHandler());</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line">executorService.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例:</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//操作语句</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>扩展参考：<a href="https://blog.mindorks.com/threadpoolexecutor-in-android-8e9d22330ee3" target="_blank" rel="noopener">https://blog.mindorks.com/threadpoolexecutor-in-android-8e9d22330ee3</a></p>
<ul>
<li><code>【强制】</code> 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让开发者更加明确线程池的运行规则，规避资源耗尽的风险。</li>
</ul>
<blockquote>
<p>说明：Executors返回的线程池对象的弊端：1.FixedThreadPool和SingleThreadPool：允许请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM；2.CachedThreadPool和ScheduledThreadPool：允许请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">int</span> NUMBER_OF_CORES = Runtime.getRuntime().avilableProcessors();</span><br><span class="line"><span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">1</span>;</span><br><span class="line">TimeUnit KEEP_ALIVE_TIME_UNIT = TimeUnit.SECONDS;</span><br><span class="line">BlockQueue&lt;Runnable&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(NUMBER_OF_CORES, NUMBER_OF_CORES*<span class="number">2</span>, KEEP_ALIVE_TIME, KEEP_ALIVE_TIME_UNIT, taskQueue, <span class="keyword">new</span> BackgroundThreadFactory(), <span class="keyword">new</span> DefaultRejectedExecutionHandler());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
<p>扩展参考 <a href="http://dev.bizo.com/2014/06/cached-thread-pool-considered-harmlful.html" target="_blank" rel="noopener">http://dev.bizo.com/2014/06/cached-thread-pool-considered-harmlful.html</a></p>
<ul>
<li><code>【强制】</code> 子线程中不能更新界面，更新界面必须在主线程中进行，网络操作不能再主线程中调用。</li>
<li><code>【强制】</code> 不要在非ui线程中初始化ViewStub，否则会返回null；</li>
<li><code>【推荐】</code> 尽量减少不同APP之间的进程间通信以及拉起行为。拉起导致占用系统资源，影响用户体验。</li>
<li><code>【推荐】</code> 新建线程时，定义能识别自己业务的线程名称，便于性能优化和问题排查。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Tread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"ThreadName"</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code> ThreadPoolExectuor设置线程存活时间(setKeepAliveTime)，确保空闲时线程能被释放。</li>
<li><code>【推荐】</code> 禁止在多进程之间用SharedPreferences共享数据，虽然可以(MODE_MULTI_PROCESS)，但官方已不推荐。</li>
<li><code>【推荐】</code> 谨慎使用Android的多进程，多进程虽然能够降低主进程的内存压力，但会遇到如下问题：<ul>
<li>不能实现完全退出所有Activity的功能</li>
<li>首次进入新启动进程的页面时会有延时的现象（有可能黑屏、白屏几秒，是白屏还是黑屏和新Activity的主题有关）</li>
<li>应用内多进程时，Application实例化多次，需要考虑各个模块是否都需要在所有进程中初始化</li>
<li>多进程间通过SharedPreferences共享数据时不稳定</li>
</ul>
</li>
</ul>
<h2 id="六-文件与数据库"><a href="#六-文件与数据库" class="headerlink" title="六 文件与数据库"></a>六 文件与数据库</h2><ul>
<li><code>【强制】</code> 任何时候不要硬编码文件路径，请使用Android文件系统API访问<ul>
<li>android.os.Environment#getExternalStorageDirectory()</li>
<li>android.os.Environment#getExternalStoragePublicDirectory()</li>
<li>android.content.Context#getFilesDir()</li>
<li>android.content.Context#getCacheDir()</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明：Android应用提供内部和外部存储，分别用于存放应用自身数据以及应用产生的用户数据。可以通过相关API接口获取对应的目录，进行文件操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getDir</span><span class="params">(String alName)</span></span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), alName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!file.mkdirs())&#123;</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"Dirctory not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getDir</span><span class="params">(String alName)</span></span>&#123;</span><br><span class="line">    <span class="comment">//任何时候都不要硬编码文件路径，这不仅存在安全隐患，也让app更容易出现适配问题</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"/mnt/sdcard/Download/Album"</span>, alName);</span><br><span class="line">    <span class="keyword">if</span>(!file.mkdirs())&#123;</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"Dirctory not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展参考：</p>
<p><a href="https://developer.android.com/training/data-storage/files.html" target="_blank" rel="noopener">https://developer.android.com/training/data-storage/files.html</a></p>
<p><a href="https://developer.android.com/reference/android/os/Environment.html#getExternalStorageDirectory" target="_blank" rel="noopener">https://developer.android.com/reference/android/os/Environment.html#getExternalStorageDirectory</a></p>
<ul>
<li><code>【强制】</code> 当使用外部存储时，必须检查外部存储的可用性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="comment">//读写检查</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> is <span class="title">ExternalStorageWritable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span>(Environment.MEDIA_MOUNTED.equals(state))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只读检查</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> is <span class="title">ExternalStorageReadable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span>(Environment.MEDIA_MOUNTED_READ_ONLY.equals(state))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code> 应用间共享文件时，不要通过放宽文件系统权限的方式去实现，而应使用FileProvider。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//正例：</span><br><span class="line"><span class="comment">&lt;!--AndroidManifest.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">"com.example.fileprovider"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:resource</span>=<span class="string">"@xml/provider_paths"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--res/xml/provider_pahts.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">path</span>=<span class="string">"album/"</span> <span class="attr">name</span>=<span class="string">"myimages"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAlumnImage</span><span class="params">(Stirng imagePath)</span></span>&#123;</span><br><span class="line">    File image = <span class="keyword">new</span> File(imagePath);</span><br><span class="line">    Intent getAlbumImageIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    Uri imageUri = FileProvider.getUriForFile(<span class="keyword">this</span>,<span class="string">"com.example.provider"</span>,image);</span><br><span class="line">    getAlbumImageIntent.getExtra(MediaStore.EXTRA_OUTPUT,imageUri);</span><br><span class="line">    startActivityForResult(taskPhotoIntent.REQUEST_GET_ALBUMIMAGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAlumnImage</span><span class="params">(Stirng imagePath)</span></span>&#123;</span><br><span class="line">    File image = <span class="keyword">new</span> File(imagePath);</span><br><span class="line">    Intent getAlbumImageIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    <span class="comment">//不要使用 file:// 的URI分享文件给别的应用，包括但不限于Intent</span></span><br><span class="line">    Uri imageUri = FileProvider.getUriForFile(<span class="keyword">this</span>,<span class="string">"com.example.provider"</span>,image);</span><br><span class="line">    getAlbumImageIntent.getExtra(MediaStore.EXTRA_OUTPUT,imageUri);</span><br><span class="line">    startActivityForResult(taskPhotoIntent.REQUEST_GET_ALBUMIMAGE);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code> SharedPreferences中只能存储简单数据类型(int/boolean/String等)，复杂数据类型建议使用文件、数据库等其他方式存储。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSettings</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SharedPreferences mySharedPreferences = getSharedPreferences(<span class="string">"settings"</span>, Activity.MODE_PRIVATE);</span><br><span class="line">    SharedPreferences.Editor editor = mySharedPreferences.edit();</span><br><span class="line">    editor.putString(<span class="string">"id"</span>,<span class="string">"foo"</span>);</span><br><span class="line">    editor.putString(<span class="string">"nick"</span>,<span class="string">"bar"</span>);</span><br><span class="line">    <span class="comment">//不要把复杂数据类型转成String存储</span></span><br><span class="line">    editor.apply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code> SharedPrefernece提交数据时，尽量使用Editor#apply()，而非Editor#commit()。一般来说，仅当需要确定提交结果，并据此有后续操作时，才使用Editor#commit().</li>
</ul>
<blockquote>
<p>说明：SharedPreference相关修改使用apply方法进行提交会先写入内存，然后异步写入磁盘，commit方法是直接写入磁盘。如果频繁操作的话apply的性能会优于commit，apply会将最后修改内容写入磁盘。但是如果希望里可获取存储操作的结果，并据此做相应的其他操作，应当使用commit。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSettingsAsync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SharedPreferences mySharedPreferences = getSharedPreferences(<span class="string">"settings"</span>, Activity.MODE_PRIVATE);</span><br><span class="line">    SharedPreferences.Editor editor = mySharedPreferences.edit();</span><br><span class="line">    editor.putString(<span class="string">"id"</span>,<span class="string">"foo"</span>);</span><br><span class="line">    editor.apply();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSettings</span><span class="params">()</span></span>&#123;</span><br><span class="line">     SharedPreferences mySharedPreferences = getSharedPreferences(<span class="string">"settings"</span>, Activity.MODE_PRIVATE);</span><br><span class="line">    SharedPreferences.Editor editor = mySharedPreferences.edit();</span><br><span class="line">    editor.putString(<span class="string">"id"</span>,<span class="string">"foo"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!editor.commit())&#123;</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"Failed to commit setting changes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">editor.putLong(<span class="string">"key_name"</span>,<span class="string">"long value"</span>);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure>
<p>扩展参考：<a href="https://developer.android.com/reference/android/content/SharedPreferences.Editor.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/content/SharedPreferences.Editor.html</a></p>
<ul>
<li><code>【强制】</code> 数据库Cursor必须确保使用完后关闭，以免内存泄漏。</li>
</ul>
<blockquote>
<p>说明：Cursor是对数据库查询结果集管理的一个类，当查询的结果集较小时，消耗内存不易察觉。但是当结果集较大，长时间重复操作会导致内存消耗过大，需要开发者在操作完成后手动关闭Cursor。数据库Cursor在创建及使用时，可能发生各种异常，无论程序是否正常结束，必须在最后确保Cursor正确关闭，以避免内存泄漏。同时，如果Cursor的使用还牵涉多线程场景，那么需要自行保证操作同步。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePhoto</span><span class="params">(SQLiteDatabase db, String userId)</span></span>&#123;</span><br><span class="line">    Cursor cursor;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        cursor = db.query(TUserPhoto, <span class="keyword">new</span> String[]&#123;<span class="string">"userId"</span>,<span class="string">"content"</span>&#125;, <span class="string">"userId=?"</span>,<span class="keyword">new</span> String[]&#123;userId&#125;,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Excption e)&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cursor!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePhotos</span><span class="params">(SQLiteDatebase db, String userId)</span></span>&#123;</span><br><span class="line">    Cursor cursor = db.query(TUserPhoto, <span class="keyword">new</span> String[]&#123;<span class="string">"userId"</span>,<span class="string">"content"</span>&#125;, <span class="string">"userId=?"</span>,<span class="keyword">new</span> String[]&#123;userId&#125;,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//不能放任cursor不关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code> 多线程操作写入数据库时，需要使用事务，以避免出现同步问题。</li>
</ul>
<blockquote>
<p>说明：Android通过SQLiteOpenHelper获取数据库SQLiteDatebase实例，Helper中会自动缓存已经打开的SQLiteDatabase实例，单个App中应使用SQLiteOpenHelper的单例模式确保数据库连接唯一。由于SQLite自身是数据库级锁，单个数据库操作是保证线程安全的（不能同时写入），transaction时一次院子操作，因此处于十五中的操作是线程安全的。若同时打开多个数据库连接，并通过多线程写入数据库，会导致数据库异常，提示数据库已被锁住。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inserUserPhoto</span><span class="params">(SQLiteDatabase db, String userId, String content)</span></span>&#123;</span><br><span class="line">    ContentValues cv = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    cv.put(<span class="string">"userId"</span>,userId);</span><br><span class="line">    cv.put(<span class="string">"content"</span>, content);</span><br><span class="line">    db.beginTransaction();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        db.insert(TUserPhoto, <span class="keyword">null</span>, cv);</span><br><span class="line">        <span class="comment">//其他操作</span></span><br><span class="line">        db.setTransactionSuccessful();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        db.endTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inserUserPhoto</span><span class="params">(SQLiteDatabase db, String userId, String content)</span></span>&#123;</span><br><span class="line">    ContentValues cv = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    cv.put(<span class="string">"userId"</span>,userId);</span><br><span class="line">    cv.put(<span class="string">"content"</span>, content);</span><br><span class="line">    db.beginTransaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展参考：</p>
<p><a href="https://nfrolov.wordpress.com/2014/08/16/android-sqlitedatabase-locking-and-multi-threading" target="_blank" rel="noopener">https://nfrolov.wordpress.com/2014/08/16/android-sqlitedatabase-locking-and-multi-threading</a><br><a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#beginTransaction()" target="_blank" rel="noopener">https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#beginTransaction()</a><br><a href="https://www.androiddesignpatterns.com/2012/05/correctly-managing-your-sqlite-database.html" target="_blank" rel="noopener">https://www.androiddesignpatterns.com/2012/05/correctly-managing-your-sqlite-database.html</a><br><a href="https://www.jianshu.com/p/57eb08fe071d" target="_blank" rel="noopener">https://www.jianshu.com/p/57eb08fe071d</a></p>
<ul>
<li><code>【推荐】</code>大数据写入数据库时，请使用事务或其他能够提高I/O效率的机制，保证执行速度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inserBulk</span><span class="params">(SQLiteDatabase db, ArrayList&lt;UserInfo&gt; users)</span></span>&#123;</span><br><span class="line">    db.beginTrasaction();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; users.size; i++)&#123;</span><br><span class="line">        ContentValues cv = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        cv.put(<span class="string">"userId"</span>,users[i].userId);</span><br><span class="line">        cv.put(<span class="string">"content"</span>, users[i].content);</span><br><span class="line">        db.insert(TUserPhoto, <span class="keyword">null</span>, cv)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其他操作</span></span><br><span class="line">        db.setTransactionSuccessful();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        db.endTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code> 执行SQL语句时，应使用SQLiteDatabase#insert()/update()/delete()，不要使用SQLiteDatabase#execSQL()，以免SQL注入风险。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUserPhoto</span><span class="params">(SQLiteDatabase db, String userId, String content)</span></span>&#123;</span><br><span class="line">    ContentValues cv = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    cv.put(<span class="string">"content"</span>, content);</span><br><span class="line">    String[] args = &#123;String.valueOf(userId)&#125;;</span><br><span class="line">    <span class="keyword">return</span> db.update(TUserPhoto, cv, <span class="string">"userId=?"</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUserPhoto</span><span class="params">(SQLiteDatabase db, String userId, String content)</span></span>&#123;</span><br><span class="line">    String sqlStmt = String.format(<span class="string">"UPDATE %s SET content=%s WHERE userId=%s"</span>, TUserPhoto, userId, content);</span><br><span class="line">    <span class="comment">//请提高安全意识，不要直接执行字符串作为SQL语句</span></span><br><span class="line">    db.execSQL(sqlStmt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code> 如果ContentProvider管理的数据存储在SQL数据库中，应该避免将不受信任的外部数据直接凭借在原始SQL语句中，可使用一个用于将<code>?</code>作为可替换参数的选择自居以及一个单独的选择参数数组，会避免SQL注入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="comment">//使用一个可替换参数</span></span><br><span class="line">String mSelectionClause = <span class="string">"var = ?"</span></span><br><span class="line">String[] selectionArgs = &#123;<span class="string">""</span>&#125;;</span><br><span class="line">selectionArgs[<span class="number">0</span>] = mUserInput;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line"><span class="comment">//拼接用户输入内容和列名</span></span><br><span class="line">String mSelectionClause = <span class="string">"var ="</span> + mUserInput;</span><br></pre></td></tr></table></figure>
<h2 id="七-Bitmap-Drawable与动画"><a href="#七-Bitmap-Drawable与动画" class="headerlink" title="七 Bitmap/Drawable与动画"></a>七 Bitmap/Drawable与动画</h2><ul>
<li><code>【强制】</code>加载大图片或者一次性加载多张图片，应该在异步线程中进行。图片的加载，涉及到IO操作，以及CPU密集操作，很可能引起卡顿</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>,<span class="title">Void</span>,<span class="title">Bitmap</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在后台进行图片解码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Intege...params)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Bitmap bitmap = BitmapFactory.decodeFile(<span class="string">"some path"</span>);</span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">Button btnLoadImage = (Button)findViewById(R.id.btn);</span><br><span class="line">btnLoadImage.setOnClickListener(<span class="keyword">new</span> OnClickListner()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">        Bitmap bitmap = BitmapFactory.decodeFile(<span class="string">"some path"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>在ListView,ViewPager,RecyclerView,GridView等组件中使用图片时，应做好图片的缓存，避免始终持有图片导致内存泄漏，也避免重复创建图片，引起性能问题。建议使用<a href="https://github.com/facebook/fresco" target="_blank" rel="noopener">Fresco</a>/<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a>等图片库。</li>
<li><code>【强制】</code>png图片使用tinypng或者类似工具压缩处理，减少包体积。</li>
<li><code>【推荐】</code>应根据实际展示需要，压缩图片，而不是直接显示原图。手机屏幕比较小，直接先是原图，并不会增加视觉上的收益，但是却会消耗大量宝贵的内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resouces res, <span class="keyword">int</span> resId, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span></span>&#123;</span><br><span class="line">    <span class="comment">//首先通过 inJustDecodeBounds=true获得图片尺寸</span></span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Option opitons = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeResouce(res,resId,options);</span><br><span class="line">    <span class="comment">//然后根据图片分辨率以及我们实际需要展示的大小，计算压缩率</span></span><br><span class="line">    options.inSampleSize = calculateInSampleSize(options,reqWidth, reqHeight);</span><br><span class="line">    <span class="comment">//设置压缩率，并解码</span></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>使用完毕的图片，应该及时回收，释放宝贵的内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">loadBitmapAsync(<span class="keyword">new</span> OnResult(result)&#123;</span><br><span class="line">    bitmap = result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//---使用该Bitmap--//</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用结束，在2.3.3及以下需要调用recycle()函数，在2.3.3以上GC会自动管理，除非你明确不需要在使用。</span></span><br><span class="line"><span class="keyword">if</span>(Build.VERSION.SDK_INK &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">    bitmap.recycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bitmap = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>针对不同的屏幕密度，提供对应的图片资源，使内存占用和显示效果达到合理的平衡。如果为了节省宝体积，可以在不影响UI效果的前提下，省略低密度图片。</li>
<li><code>【强制】</code>在Activity.onPause()或Activity.onStop()回调中关闭当前activity正在执行的动画。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">    ImageView mImageView;</span><br><span class="line">    Animation mAnimation;</span><br><span class="line">    Button mBtn;</span><br><span class="line">    <span class="comment">/** 首次创建activity时调用**/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstaceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line">        setContentVew(R.layout.main);</span><br><span class="line">        mImageView = (ImageView)findViewById(R.id.ImageVIew01);</span><br><span class="line">        mAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>,R.anim.anim);</span><br><span class="line">        mBtn = (Button)findViewById(R.id.Button01);</span><br><span class="line">        mBtn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                mImageView.startAnimation(mAnimation)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//页面退出，及时清理动画资源</span></span><br><span class="line">        mImageView.clearAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>在动画或者其他异步任务结束时，应该考虑回调时刻的环境是否还支持业务处理。例如Activity的onStop()函数已经执行，且在该函数中主动释放了资源，此时回调中如果不做判断就会空指针崩溃。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">    ImageView mImageView;</span><br><span class="line">    Animation mAnimation;</span><br><span class="line">    Button mBtn;</span><br><span class="line">    <span class="comment">/** 首次创建activity时调用**/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstaceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line">        setContentVew(R.layout.main);</span><br><span class="line">        mImageView = (ImageView)findViewById(R.id.ImageVIew01);</span><br><span class="line">        mAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>,R.anim.anim);</span><br><span class="line">        mAnimation.setAnimationListener(<span class="keyword">new</span> AnimationListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation arg0)</span></span>&#123;</span><br><span class="line">                <span class="comment">//判断一下资源是否被释放了</span></span><br><span class="line">                <span class="keyword">if</span>(mImageView!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    mImageView.clearAnimation();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mImageView.startAnimation(mAnimation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>使用inBitmap重复利用内存空间，避免重复开辟新内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromFile</span><span class="params">(String filename, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight, ImageCache cache)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    ...</span><br><span class="line">    BitmapFactory.decodeFile(filename,options);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果在Honeycomb或更新版本系统中运行，尝试使用inBitmap</span></span><br><span class="line">    <span class="keyword">if</span>(Utils.hasHoneycomb())&#123;</span><br><span class="line">        addInBitmapOptions(options,cache);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeFile(filename, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInBitmapOptions</span><span class="params">(BitmapFactory.Options options, ImageCache cache)</span></span>&#123;</span><br><span class="line">    <span class="comment">//inBitmap 只处理可变的位图，所以强制返回可变的位图</span></span><br><span class="line">    options.inMutable=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(cache!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Bitmap inBitmap = cache.getBitmapFromReusableSet(Options);</span><br><span class="line">        <span class="keyword">if</span>(inBitmap!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            options.inBitmap=inBitmap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>使用ARGB_565代替ARGB_888，在不怎么降低视觉效果的前提下，减少内存占用。</li>
</ul>
<blockquote>
<p>说明：android.graphics.Bitmap.Config类中关于图片颜色的存储方式定义：ALPHA_8代表8位Alpha位图，ARGB_4444代表16位ARGB图，ARGB_8888代表32位ARGB位图，RGB_565代表8位RGB位图。位图数越高，存储的颜色信息越多，图像也就越逼真。大多数场景使用的是ARGB_8888和RGB_565，RGB_565能够在保证图片质量的情况下大大减少内存的开销，是解决OOM的一种方法。但是一定要注意RGB_565是没有透明度的，如果图片本身需要保留透明度，那么久不能使用RGB_565。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">Config config = drawableSave.getOpacity()!=PixelFormat.OPAQUE?Config.ARGB_8888:Config.RGB_565;</span><br><span class="line">Bitmap bitmap = Bitmap.createBitmap(w,h,config);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">Bitmap newbitmap = Bitmap.createBitmap(width,height,Config.ARGB_8888);</span><br></pre></td></tr></table></figure>
<p>扩展参考：</p>
<p><a href="https://www.jianshu.com/p/294b390eb6f7" target="_blank" rel="noopener">https://www.jianshu.com/p/294b390eb6f7</a></p>
<p><a href="https://www.programcreek.com/java-api-examples/android.graphics.Bitmap.Config" target="_blank" rel="noopener">https://www.programcreek.com/java-api-examples/android.graphics.Bitmap.Config</a></p>
<ul>
<li><code>【推荐】</code>尽量减少Bitmap(BitmapDrawable)的使用，尽量使用纯色(ColorDrawable)、渐变色(GradientDrawable)、StateSelector(StateListDrawale)等与Shape结合的形式构建绘图。</li>
<li><code>【推荐】</code>谨慎使用gif图片，注意限制每个页面允许同时播放的gif图片，以及单个gif图片的大小</li>
<li><code>【参考】</code>大图片资源不要直接打包到apk，可以考虑通过文件仓库远程下载，减小包体积。</li>
<li><code>【推荐】</code>根据设备性能，选择性开启复杂动画，以实现一个整体较优的性能和体验；</li>
<li><code>【推荐】</code>在有强依赖onAnimationEnd回调的交互时，如动画播放完毕才能操作页面，onAnimationEnd 可能会因各种异常没被回调(参考 <a href="https://stackoverflow.com/questions/5474923/onanimationend-is-not-getting-called-onanimationstart-works-fine" target="_blank" rel="noopener">https://stackoverflow.com/questions/5474923/onanimationend-is-not-getting-called-onanimationstart-works-fine</a>)，建议加上超市保护或通过postDelay替代onAnimationEnd。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">View v = findViewById(R.di.xxxViewID);</span><br><span class="line"><span class="keyword">final</span> FadeUpAnimation anim = <span class="keyword">new</span> FadeUpAnimation(v);</span><br><span class="line">anim.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());</span><br><span class="line">anim.setDuration(<span class="number">1000</span>);</span><br><span class="line">anim.setFillAfter(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            v.clearAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,anim.getDuration());</span><br><span class="line">v.startAnimation(anim);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>当View Animation执行结束时，调用View.clearAnimation()释放相关资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">View v = findViewById(R.di.xxxViewID);</span><br><span class="line"><span class="keyword">final</span> FadeUpAnimation anim = <span class="keyword">new</span> FadeUpAnimation(v);</span><br><span class="line">anim.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());</span><br><span class="line">anim.setDuration(<span class="number">1000</span>);</span><br><span class="line">anim.setFillAfter(<span class="keyword">true</span>);</span><br><span class="line">anim.setAnimationListener(<span class="keyword">new</span> AnimationListner()&#123;</span><br><span class="line">    <span class="comment">//判断一下资源是否被释放了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimaitonEnd</span><span class="params">(Animation arg0)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            v.clearAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">v.startAnimation(anim);</span><br></pre></td></tr></table></figure>
<h2 id="八-安全"><a href="#八-安全" class="headerlink" title="八 安全"></a>八 安全</h2><ul>
<li><code>【强制】</code>使用PendingIntent时，禁止使用空intent，同时禁止使用隐式Intent</li>
</ul>
<blockquote>
<p>说明：1)使用PendingIntent时，使用了空Intent，会导致恶意用户劫持修改Intent的内容。禁止使用一个空Intent去构造PendingIntent，构造PendingIntent的Intent一定要设置ComponentName或者action.2)PendingIntent可以让其他App中的代码像是运行在自己App中。PendingIntent的intent接收方在使用该intent时与发送方有相同的权限。在使用PendingIntent时，PendingIntent中包装的intent如果是隐式是Intent，容易遭到劫持，导致信息泄露。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SomeActivity.class);</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">1</span>,intent,PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    pendingIntent.send();</span><br><span class="line">&#125;<span class="keyword">catch</span>(PendingIntent.CaceledException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例1：</span></span><br><span class="line">Bundle addAccountOptions = <span class="keyword">new</span> Bundle();</span><br><span class="line">mPendingIntent = PendingIntent.getBroadcast(<span class="keyword">this</span>,<span class="number">0</span>,<span class="keyword">new</span> Intent, <span class="number">0</span>);</span><br><span class="line">addAccountOptions.putParcelable(KEY_CALLER_IDENITY,mPendingIntent);</span><br><span class="line">addAccountOptions.putBoolean(EXTRA_HAS_MULTIPLE_USERS, Utils.hasMultipleUsers(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">AccountManager.get(<span class="keyword">this</span>).addAccount(accountType, <span class="keyword">null</span>, <span class="keyword">null</span>, addAccountOptions, <span class="keyword">null</span>, mCallback, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例2：</span></span><br><span class="line"><span class="comment">//mPendingIntent是通过new Intent()构造原始Intent的，所以为“双无”Intent，这个PendingIntent最终被通过AccountManager.addAcount方法传递给了恶意App接口。</span></span><br><span class="line"></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.test.pushservice.aciton.METHOD);</span></span><br><span class="line"><span class="string">intent.addFlags(32);</span></span><br><span class="line"><span class="string">intent.putExtra("</span>app<span class="string">", PendingIntent.getBroadcast(this,0,intent,0));</span></span><br></pre></td></tr></table></figure>
<p>扩展参考：</p>
<p><a href="https://developer.android.com/reference/android/app/PendingIntent.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/PendingIntent.html</a></p>
<p><a href="https://wiki.sei.cmu.edu/confluence/display/android/DRD21-J.+Always+pass+explicit+intents+to+a+PendingIntent" target="_blank" rel="noopener">https://wiki.sei.cmu.edu/confluence/display/android/DRD21-J.+Always+pass+explicit+intents+to+a+PendingIntent</a></p>
<p><a href="http://www.droidsec.cn/android-broadcastanywhere%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90" target="_blank" rel="noopener">http://www.droidsec.cn/android-broadcastanywhere%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</a></p>
<ul>
<li><code>【强制】</code>禁止使用常量初始化矢量参数构建IvParameterSpec，建议IV通过随机方式产生。</li>
</ul>
<blockquote>
<p>说明：使用固定初始化向量，结果密码文本可预测性会高很多，容易受到字典式攻击。iv的作用主要是用于产生密文的第一个block，以使最终生成的密文产生差异（明文相同的情况下），使密码攻击变得困难，除此之外iv并无其他用途。因此iv通过随机方式产生是一种十分简便、有效的途径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">byte</span>[] rand = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">SecureRandom r = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">r.nextByte(rand);</span><br><span class="line">IvParameterSpec iv = <span class="keyword">new</span> IvParamterSpec(rand);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">IvParameterSpec iv = <span class="keyword">new</span> IvParamterSpec(<span class="string">"1234567890"</span>.getBytes());</span><br><span class="line">System.out.println(iv.getIV());</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>将android:allowbackup属性设置为false，防止adb backup导出数据</li>
</ul>
<blockquote>
<p>说明：在AndroidManifest.xml文件中为了方便对程序数据的备份和恢复，在Android API level 8以后增加了android:allowBackup属性。默认情况下这个属性值为true，故当allowBackup标志值为true时，即可通过adb backup和adb restore来备份和恢复应用程序数据。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//正例：</span><br><span class="line"><span class="tag">&lt;<span class="name">applicaiton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allow</span><span class="attr">Backup</span>=<span class="string">"fasle"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:largeHeap</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"@drawable/test_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>在实现的HostnameVerifier子类中，需要使用verify函数校验服务器主机名的合法性，否则会导致恶意程序利用中间人攻击绕过主机校验。</li>
</ul>
<blockquote>
<p>说明：在握手期间，如果URL的主机名和服务器的标识主机名不匹配，则验证机制可以回调此接口的实现程序来确定是否应该允许此连接。如果回调内实现不恰当，默认接收所有域名，则有安全风险。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">HostnameVerifier hnv = <span class="keyword">new</span> HostnameVerifier()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession sessiont)</span></span>&#123;</span><br><span class="line">        <span class="comment">//总是返回true，接收任意域名服务器</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"yourhostname"</span>.equals(hostname))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            HostnameVerifier hv = HttpURLConnection.getDefaultHostnameVerifier();</span><br><span class="line">            <span class="keyword">return</span> hv.verify(hostname,session)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">HttpsURLConnection.setDefaultHostnameVerifier(hnv);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">HostnameVerifier hnv = <span class="keyword">new</span> HostnameVerifier()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession sessiont)</span></span>&#123;</span><br><span class="line">        <span class="comment">//总是返回true，接收任意域名服务器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">HttpsURLConnection.setDefaultHostnameVerifier(hnv);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>利用X509TrustManager子类中的checkServerTrusted函数校验服务器端证书的合法性。</li>
</ul>
<blockquote>
<p>说明：在实现的X509TrustManager子类中未对服务端的证书做校验，这样会导致不被信任的证书绕过证书校验机制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">TrustManager tm = <span class="keyword">new</span> X509TrustManager()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span><span class="keyword">throws</span> CertificateExcepiton</span>&#123;</span><br><span class="line">        <span class="comment">//do nothing,接收任意客户端证书</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span>hrows CertificateExcepiton</span>&#123;</span><br><span class="line">        <span class="comment">//do nothing,接收任意服务端证书</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sslContext.init(<span class="keyword">null</span>,<span class="keyword">new</span> TrustManager[]&#123;tm&#125;,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>META-INF目录中不能包含如.apk/.odex/.so等敏感文件，该文件夹没有经过签名，容易被恶意替换。</li>
<li><code>【强制】</code>Receiver/Provider不能在毫无权限控制的情况下将android:export设置为true。</li>
<li><code>【参考】</code>数据存储在Sqlite或者轻量级存储需要对数据进行加密，取出来的时候进行解密。</li>
<li><code>【强制】</code>阻止WebView通过file:schema方式访问本地敏感数据。</li>
<li><code>【强制】</code>不要广播敏感信息，只能在本应用使用LocalBroadcast，避免被别的应用收到，或者setPackage做限制。</li>
<li><code>【强制】</code>不要把敏感信息打印到log中</li>
</ul>
<blockquote>
<p>说明：在App的开发过程中，为了方便调试，通常会使用log函数输出一些关键流程的信息，这些信息中通常会包含敏感内容，如执行流程、明文的用户名密码等，这会让攻击者更加容易了解App内部结构方便破解和攻击，甚至直接获取到有价值的敏感信息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">String username = <span class="string">"log_leak"</span>;</span><br><span class="line">String password = <span class="string">"log_leak_pwd"</span>;</span><br><span class="line">Log.d(<span class="string">"MY_APP"</span>,<span class="string">"username"</span> + username);</span><br><span class="line">Log.d(<span class="string">"MY_APP"</span>,<span class="string">"password"</span> + password, <span class="keyword">new</span> Throwable());</span><br><span class="line">Log.d(<span class="string">"MY_APP"</span>,<span class="string">"send message to server"</span>);</span><br><span class="line"><span class="comment">//以上代码使用Log.d/Log.v打印程序的执行过程的username等调试信息，日志没有关闭，攻击者可以直接从Logcat读取这些敏感信息。所以在产品的线上版本中关闭调试接口，不要输出敏感信息。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>对于内部使用的组件，显示设置组件的”android:exported”属性为false。</li>
</ul>
<blockquote>
<p>说明：Android应用使用Intent机制在组件之间传递数据，如果应用在使用getIntent()/getAction()/Intent/getXXXExtra()获取到空数据、异常或者畸形数据时没有进行异常捕获，应用就会发生Crash，应用不可使用（本地拒绝服务）。恶意应用可通过向受害者应用发送此空数据、异常或者机型数据从而使应用产生本地拒绝服务。</p>
</blockquote>
<ul>
<li><code>【强制】</code>应用发布前确保android:debuggable属性设置为false。</li>
<li><code>【强制】</code>使用Intent Scheme URL需要做过滤。</li>
</ul>
<blockquote>
<p>说明：如果浏览器支持Intent Scheme Uri语法，如果过滤不当，那么恶意用户可能通过浏览器js代码进行一些恶意行为，比如盗取cookie等。如果使用了Intent.parseUri函数，获取的intent必须严格过滤，intent至少包含addCategory(“android.intent.category.BROWASABLE”)，setComponent(null)，setSelector(null)3个策略。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="comment">//将intnet scheme URL转换为intent对象</span></span><br><span class="line">Intent intent = Intent.parseUri(uri);</span><br><span class="line"><span class="comment">//禁止没有BROWSABLE categroy的情况下启动activity</span></span><br><span class="line">intent.addCategory(<span class="string">"android.intent.category.BROWSABLE"</span>);</span><br><span class="line">intent.setComponent(<span class="keyword">null</span>);</span><br><span class="line">intent.setSelector(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//使用intent启动activity</span></span><br><span class="line">context.startActivityIfNeeded(intent,-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">Intent intent = Intent.parseUri(uri.toString.trim().substring(<span class="number">15</span>),<span class="number">0</span>);</span><br><span class="line">intent.addCategory(<span class="string">"android.intent.category.BROWSABLE"</span>);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>扩展参考：</p>
<p><a href="https://jaq.alibaba.com/community/art/show?articleid=265" target="_blank" rel="noopener">https://jaq.alibaba.com/community/art/show?articleid=265</a></p>
<p><a href="https://www.mbsd.jp/Whitepaper/IntentScheme.pdf" target="_blank" rel="noopener">https://www.mbsd.jp/Whitepaper/IntentScheme.pdf</a></p>
<ul>
<li><code>【强制】</code>密钥加密存储或者经过变形处理后用于加解密运算，切勿硬编码到代码中。</li>
</ul>
<blockquote>
<p>说明：应用程序在加解密时，使用硬编码在程序中的密钥，攻击者通过反编译拿到密钥可以轻易解密App通信数据。</p>
</blockquote>
<ul>
<li><code>【强制】</code>将所需要动态加载的文件放置在apk内部，或应用私有目录中，如果应用必须要把所加载的文件放置在可被其他应用读写的目录中（比如sdcard），建议对不可信的加载源进行完整性校验和白名单处理，以保证不被恶意代码注入。</li>
<li><code>【强制】</code>除非min API level &gt;= 17，请注意addJavascriptInterface的使用。</li>
</ul>
<blockquote>
<p>说明：API level &gt;= 17，允许js被调用的函数必须以@JavascripteInterface进行注解，因此不受影响；对于API level &lt; 17，尽量不要使用addJavascriptInterface，如果一定要用那么：1）使用https协议加载url，使用证书校验，防止访问的页面被篡改挂马；2）对加载URL做白名单过滤、完整性校验等防止访问的页面被篡改；3）如果加载本地html，应该会HTML内置在APK中，以及对HTML页面进行完整校验。</p>
</blockquote>
<ul>
<li><code>【强制】</code>使用Android的AES/DES/DESede加密算法时，不要使用默认的加密模式ECB，应显示指定使用CBC或CFB加密模式。<ul>
<li>ECB:Electronic codebook 电子密码本模式</li>
<li>CBC:Cipher-block chaning，密码分组链接模式</li>
<li>CFB:Cipher feedback，密文反馈模式</li>
<li>OFB:Output feedback,输出反馈模式</li>
</ul>
</li>
</ul>
<blockquote>
<p>说明:加密模式ECB/CBC/CFB/OFB等，其中ECB的安全性较弱，会使相同的铭文在不同的时候产生相同的密文，容易遇到字典攻击，建议使用CBC或CFB模式。</p>
</blockquote>
<ul>
<li><code>【强制】</code>不要使用lookback 来通信敏感信息。</li>
<li><code>【推荐】</code>对于不需要使用File协议的应用，禁用File协议，显示设置webView.getSettings().setAllowFileAccess(false)，对于需要使用File协议的应用，禁止File协议调用JavaScript，显示设置webView.getSettings.setJavaScriptEnabled(false)。</li>
<li><code>【强制】</code>Android APP在HTTPS通信中，验证策略需要改成严格模式。</li>
</ul>
<blockquote>
<p>说明：Android App在https通信中，使用ALLOW_ALL_HOSTNAME_VERIFIER，表示允许和所有的HOST建立SSL通信，这会存在中间人攻击的风险，最终导致敏感信息可能会被劫持，以及其他形式的攻击。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">SSLSocketFactory sf = <span class="keyword">new</span> MySSLSocketyFactory(trustStore);</span><br><span class="line">sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);</span><br><span class="line"><span class="comment">//ALLOW_ALL_HOSTNAME_VERIFIER关闭host验证，允许和所有的host简历SSL通信，BROWSER_COMPATIBLE_HOSTNAME_VERIFIER和浏览器兼容的验证策略，即通配符能够匹配所有子域名，STRICT_HOSTNAME_VERIFIER严格匹配模式，hostname必须匹配第一个CN或者任何一个subject-alts，以上例子使用了ALLOW_ALL_HOSTNAME_VERIFIER，需要改成STRICT_HOSTNAME_VERIFIER。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>Android5.0以后安全性要求较高的应用应该使用window.setFlag(LayoutParam.FLAG_SECURE)禁止录屏。</li>
<li><code>【推荐】</code>zip中不建议允许<code>../../file</code>这样的路径，可能被篡改目录结构，造成供给。</li>
</ul>
<blockquote>
<p>说明：当zip压缩包中允许存在”…/“的字符串，攻击者可以利用多个”…/“在解压时改变zip文件存放的位置，当文件已经存在时就会进行覆盖，如果覆盖掉的文件时so/dex/odex文件，就有可能造成严重的安全问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="comment">//对路径进行判断，存在".."时抛出异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对重要的Zip压缩包文件进行数字签名校验，校验通过才进行解压</span></span><br><span class="line">String entryName = entry.getName();</span><br><span class="line"><span class="keyword">if</span>(entryName.contains(<span class="string">".."</span>))&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(unsecurity zipfile!);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>开放的activity/service/receiver等需要对传入的intent做合法性校验。</li>
<li><code>【推荐】</code>加密算法：使用不安全的Hash算法(MD5/SHA-1)加密信息，存在被破解的风险，建议使用SHA-256等安全性更高的Hash算法。</li>
<li><code>【推荐】</code>Android WebView组件加载网页发生证书认证错误时，采用默认的处理方法handler.cancel()，停止加载问题页面.</li>
</ul>
<blockquote>
<p>说明：Android WebView 组件加载网页发生证书认证错误时，会调用WebViewClient类的onReceivedSslError方法，如果该方法实现调用了handler.proceed()来忽略该证书错误，则会收到中间人攻击的威胁，可能导致隐私泄露。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">mWebView.addJavaScriptInterface(<span class="keyword">new</span> JsBridge(mContext),JS_OBJECT);</span><br><span class="line">mWebView.loadUrl(<span class="string">"http://www.example.com/test"</span>);</span><br><span class="line">mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedSslError</span><span class="params">(WebView view, SslErrorHandler handler, SslError error)</span></span>&#123;</span><br><span class="line">        handler.proceed();<span class="comment">//忽略SSL证书错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【推荐】</code>直接传递命令或者间接处理有敏感信息或操作时，避免使用socket实现，使用能够控制权限校验身份的方式通讯</li>
</ul>
<h2 id="九-其他"><a href="#九-其他" class="headerlink" title="九 其他"></a>九 其他</h2><ul>
<li><code>【强制】</code>不要通过Msg传递大的对象，会导致内存问题。</li>
<li><code>【强制】</code>不能使用System.out.println打印log</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line">Log.d(TAG,<span class="string">"Some Android Debug info..."</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">System.out.println(<span class="string">"System out println..."</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>【强制】</code>Log的tag不能是<code>&quot; &quot;</code>。</li>
</ul>
<blockquote>
<p>说明：日志的tag是空字符串没有任何意义，也不利于过滤日志</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正例：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String TAG = <span class="string">"LoginActivity"</span>;</span><br><span class="line">Log.e(TAG,<span class="string">"Login failed!"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反例：</span></span><br><span class="line">Log.e(<span class="string">""</span>,<span class="string">"Login failed!"</span>);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/《疯狂Android讲义》读书笔记（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老易的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/《疯狂Android讲义》读书笔记（一）/" itemprop="url">《疯狂Android讲义》读书笔记（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T16:07:25+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-Android应用和开发环境"><a href="#第一章-Android应用和开发环境" class="headerlink" title="第一章 Android应用和开发环境"></a>第一章 Android应用和开发环境</h1><h2 id="Android的发展和历史"><a href="#Android的发展和历史" class="headerlink" title="Android的发展和历史"></a>Android的发展和历史</h2><p>Android是由Andy Rubin创立的一个手机操作系统，后来被Google收购。Google希望与各方共同建立一个标准化、开放式的移动电话软件平台，从而在移动产业内形成一个开放式的操作平台。</p>
<h3 id="Android的发展和简介"><a href="#Android的发展和简介" class="headerlink" title="Android的发展和简介"></a>Android的发展和简介</h3><ul>
<li>Android不是Google创造的，而是Android公司创造的，该公司的创始人是Andy Rubin。公司后来被Google收购，而Andy Rubin也成为Google的Android项目产品负责人。</li>
<li>Google与2007年11月5日发布了Android1.0操作系统。</li>
<li>目前Android已经成为一个重要的手机操作系统。当前市场常见的操作系统如下：<ul>
<li>iOS</li>
<li>Windows Phone</li>
<li>BlackBerry</li>
<li>Symbian</li>
</ul>
</li>
</ul>
<blockquote>
<p>事实上，Android已经超出了手机操作系统的范畴，Android系统已经广泛应用于TV、手表以及各种可穿戴设备。</p>
</blockquote>
<h3 id="Android-平台架构及特性"><a href="#Android-平台架构及特性" class="headerlink" title="Android 平台架构及特性"></a>Android 平台架构及特性</h3><p>Android 系统的底层建立在Linux系统之上，该平台由操作系统、中间件、用户界面和应用软件4层组成，采用软件叠层(Software Stack)的方式进行构建。这种结构使曾与层之间互相分离，明确各层分工，保证了低耦合。</p>
<p><img src="/2018/03/13/《疯狂Android讲义》读书笔记（一）/android-stack.png" alt="平台架构"></p>
<ul>
<li>系统应用 (System Apps)：Android 系统将会包含一系列的核心应用程序</li>
<li>Java API 框架 (Java API Framework)：提供对接底层的大量接口框架，供开发者使用。</li>
<li>原生 C/C++ 函数库 (Native C/C++ Libraries)：Android 包含一套被不同组件使用的C/C++库的集合。应用开发者不能直接调用这个库集，但可以通过上面的应用程序框架来调用。<ul>
<li>系统C库：从BSD系统派生出来的标准C系统库，并且专门为嵌入式Linux设备调整过</li>
<li>媒体库：基于PacketVideo的OpenCORE，这套媒体库支持播放和录制许多流行的音频和视频格式</li>
<li>Surface Manager：管理对显示子系统的访问，并可以对多个应用程序的2D和3D图层提供无缝整合</li>
<li>LibWebCore：Web浏览器引擎，该引擎为Android浏览器提供支持，也为WebView提供支持</li>
<li>SGL：底层的2D图形引擎</li>
<li>3D Libraries：基于OpenGL ES API实现的3D系统</li>
<li>Free Type：位图和向量字体显示</li>
<li>SQLite：供所有应用程序使用的功能强大的轻量级关系数据库</li>
</ul>
</li>
<li>Android 运行时 (Android Runtime)<ul>
<li>Android 核心库集：提供 Java API 框架使用的 Java 编程语言大部分功能</li>
<li>ART(Android Runtime)：<ul>
<li>预先(AOT)和即时(JIT)编译</li>
<li>优化的垃圾回收(GC)</li>
<li>更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置检视点以监控特定字段</li>
</ul>
</li>
</ul>
</li>
<li>硬件抽象层 (HAL)</li>
</ul>
<blockquote>
<p>硬件抽象层提供标准界面，向更高级别的Java API框架显示设备硬件功能。HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当框架API要求访问设备硬件时，Android系统将为该硬件组件加载库模块。</p>
</blockquote>
<ul>
<li>Linux内核 (Linux Kernel)</li>
</ul>
<blockquote>
<p>Android 平台的基础是 Linux 内核。使用Linux内核可以让Android利用主要安全功能，并且允许设备制造商为注明的内核开发硬件驱动程序。</p>
</blockquote>
<h2 id="搭建Android开发环境"><a href="#搭建Android开发环境" class="headerlink" title="搭建Android开发环境"></a>搭建Android开发环境</h2><ul>
<li>Android Studio 是由Google开发的基于IntelliJ IDEA的Android 官方IDE，可在<a href="http://developer.android.com" target="_blank" rel="noopener">谷歌开发者网站</a>下载获取。</li>
<li>Android Studio的项目相当于一个工作空间，一个工作空间可包含多个模块，每个模块对应一个Android项目。</li>
</ul>
<h2 id="Android-常用开发工具的用法"><a href="#Android-常用开发工具的用法" class="headerlink" title="Android 常用开发工具的用法"></a>Android 常用开发工具的用法</h2><h3 id="Mac环境下配置ADB环境变量"><a href="#Mac环境下配置ADB环境变量" class="headerlink" title="Mac环境下配置ADB环境变量"></a>Mac环境下配置ADB环境变量</h3><blockquote>
<p>Mac下需要手动配置才能运行Android SDK platform-tools 中的命令</p>
</blockquote>
<ul>
<li>启动Mac终端Terminal在命令行中输入以下三行命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;export ANDROID_HOME=/Users/$USER/Library/Android/sdk&apos; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &apos;export PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools&apos; &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<h3 id="在命令行创建、删除和浏览AVD"><a href="#在命令行创建、删除和浏览AVD" class="headerlink" title="在命令行创建、删除和浏览AVD"></a>在命令行创建、删除和浏览AVD</h3><p>在命令行下管理AVD需要借助于<code>android</code>命令（位于 Android SDK 安装目录的tools子目录下），如果直接执行<code>android</code>命令将会启动Android SDK管理器，除此之外还有以下命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td>列出机器上所有已经安装的Android版本和AVD设备</td>
</tr>
<tr>
<td>ist avd</td>
<td>列出机器上所有已经安装的AVD设备</td>
</tr>
<tr>
<td>list target</td>
<td>列出机器上所有已经安装Android版本</td>
</tr>
<tr>
<td>create avd</td>
<td>创建一个AVD设备</td>
</tr>
<tr>
<td>move avd</td>
<td>移动或重命名一个AVD设备</td>
</tr>
<tr>
<td>delete avd</td>
<td>删除一个AVD设备</td>
</tr>
<tr>
<td>update avd</td>
<td>升级一个AVD设备使之符合新的SDK环境</td>
</tr>
<tr>
<td>create project</td>
<td>创建一个新的Android项目</td>
</tr>
<tr>
<td>create test-project</td>
<td>创建一个新的Android测试项目</td>
</tr>
<tr>
<td>update test-project</td>
<td>更新一个已有的Android测试项目</td>
</tr>
</tbody>
</table>
<p>如果需要创建一个全新的AVD设备，可执行如下命令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android create avd -n &lt;avd名称&gt; -t &lt;Android 版本&gt; -b &lt;CPU 架构&gt; -p &lt;AVD 设备保存位置&gt; -s &lt;选择AVD皮肤&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用真机进行调试"><a href="#使用真机进行调试" class="headerlink" title="使用真机进行调试"></a>使用真机进行调试</h3><ul>
<li>使用真机进行调试<ul>
<li>打开<code>开发者模式</code></li>
<li>打开<code>允许USB调试</code></li>
</ul>
</li>
<li>使用真机进行无线调试<ul>
<li>首先确认电脑与真机在同一个Wifi条件下</li>
<li>有线连接真机</li>
<li>输入命令<code>adb tcpip 5555</code></li>
<li>输入命令<code>adb connect</code>+手机连接WiFi所分配的IP地址+<code>5555</code></li>
</ul>
</li>
</ul>
<h3 id="Android-Debug-Bridge-ADB-的用法"><a href="#Android-Debug-Bridge-ADB-的用法" class="headerlink" title="Android Debug Bridge (ADB) 的用法"></a>Android Debug Bridge (ADB) 的用法</h3><table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>adb devices</code></td>
<td>查看当前运行的模拟器</td>
</tr>
<tr>
<td><code>adb push [电脑文件的路径] [手机(或模拟器)的路径]</code></td>
<td>电脑文件复制到手机或模拟器</td>
</tr>
<tr>
<td><code>adb pull [手机(或模拟器)的路径] [电脑文件的路径]</code></td>
<td>手机上的文件复制到电脑</td>
</tr>
<tr>
<td><code>adb shell</code></td>
<td>启动模拟器的shell窗口</td>
</tr>
<tr>
<td><code>adb install [-r] [-s] &lt;file&gt;</code></td>
<td>安装APK程序(-r表示重新安装，-s表示安装到SD卡上)</td>
</tr>
<tr>
<td><code>adb uninstall [-k] &lt;package&gt;</code></td>
<td>卸载<code>&lt;package&gt;</code>所代表的应用程序，-k表示只删除应用程序，数据和目录保留</td>
</tr>
<tr>
<td><code>mksdcard [-l label] &lt;size&gt; &lt;file&gt;</code></td>
<td>创建虚拟存储卡。<code>&lt;size&gt;</code>指定SD卡大小，<code>&lt;file&gt;</code>指定保存虚拟SD卡的文件镜像</td>
</tr>
</tbody>
</table>
<h2 id="Android-应用结构分析"><a href="#Android-应用结构分析" class="headerlink" title="Android 应用结构分析"></a>Android 应用结构分析</h2><ul>
<li>build：Android Studio开发生成的各种源文件（包括R.java文件也放在该目录的子目录下）。</li>
<li>lib：存储Android项目所需的第三方JAR包</li>
<li>src 存储Android项目开发中的各种源文件<ul>
<li>各种Java源文件（放在main/java子目录下）</li>
<li>各种资源文件（放在main/res目录下）<ul>
<li>layout 布局文件</li>
<li>values 各种XML格式的资源文件<ul>
<li>string.xml 字符串资源文件</li>
<li>colors.xml 颜色资源文件</li>
<li>dimens.xml 尺寸资源文件</li>
</ul>
</li>
<li>drawable 存放图片文件（根据ldpi/mdpi/hdpi/xhdip等来存放不同分辨率的文件）</li>
</ul>
</li>
<li>AndroidManifest.xml文件<ul>
<li>Android项目的系统清单文件，用于控制Android应用的名称、图标、访问权限等曾提属性。</li>
<li>Android应用的Activity/Service/ContentProvider/BroadcastReceiver都需要在其中配置</li>
</ul>
</li>
<li>androidTest 存放Android测试项目</li>
</ul>
</li>
</ul>
<h3 id="应用程序权限说明"><a href="#应用程序权限说明" class="headerlink" title="应用程序权限说明"></a>应用程序权限说明</h3><blockquote>
<p>通过为<code>&lt;mainifest.../&gt;</code>元素添加<code>&lt;uses-permission.../&gt;</code>子元素即可为程序本身声明权限</p>
</blockquote>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACCESS_NETWORK_STATE</td>
<td>允许应用程序获取网络状态信息的权限</td>
</tr>
<tr>
<td>ACCESS_WIFI_STATE</td>
<td>允许应用程序获取WiFi网络状态信息的权限</td>
</tr>
<tr>
<td>BATTERY_STATS</td>
<td>允许应用程序获取电池状态信息的权限</td>
</tr>
<tr>
<td>BLUETOOTH</td>
<td>允许应用程序连接匹配的蓝牙设备的权限</td>
</tr>
<tr>
<td>BLUETOOTH_ADMIN</td>
<td>允许应用程序发现匹配的蓝牙设备的权限</td>
</tr>
<tr>
<td>BROADCAST_SMS</td>
<td>允许应用程序广播收到短信提醒的权限</td>
</tr>
<tr>
<td>CALL_PHONE</td>
<td>允许应用程序拨打电话的权限</td>
</tr>
<tr>
<td>CAMERA</td>
<td>允许应用程序使用照相机的权限</td>
</tr>
<tr>
<td>CHANGE_NETWORK_STATE</td>
<td>允许应用程序改变网络连接状态的权限</td>
</tr>
<tr>
<td>CHANGE_WIFI_STATE</td>
<td>允许应用程序改变WiFi网络连接状态的权限</td>
</tr>
<tr>
<td>DELETE_CACHE_FILES</td>
<td>允许应用程序删除缓存文件的权限</td>
</tr>
<tr>
<td>DELETE_PACKAGES</td>
<td>允许应用程序删除安装包的权限</td>
</tr>
<tr>
<td>FLASHLIGHT</td>
<td>允许应用程序使用闪光灯的权限</td>
</tr>
<tr>
<td>INTERNET</td>
<td>允许应用程序打开网络Socket的权限</td>
</tr>
<tr>
<td>MODIFY_AUDIO_SETTINGS</td>
<td>允许应用程序修改全局声音设置的权限</td>
</tr>
<tr>
<td>PROCESS_OUTGOING_CALLS</td>
<td>允许应用程序监听、控制、取消呼出电话的权限</td>
</tr>
<tr>
<td>READ_CONTACTS</td>
<td>允许应用程序读取用户联系人数据的权限</td>
</tr>
<tr>
<td>READ_HISTORY_BOOKMARKS</td>
<td>允许应用程序读取历史书签的权限</td>
</tr>
<tr>
<td>READ_OWNER_DATA</td>
<td>允许应用程序读取用户数据的权限</td>
</tr>
<tr>
<td>READ_PHONE_STATE</td>
<td>允许应用程序读取电话状态的权限</td>
</tr>
<tr>
<td>READ_PHONE_SMS</td>
<td>允许应用程序读取短信的权限</td>
</tr>
<tr>
<td>REBOOT</td>
<td>允许应用程序重启系统的权限</td>
</tr>
<tr>
<td>RECEIVE_MMS</td>
<td>允许应用程序接收、监控、处理彩信的权限</td>
</tr>
<tr>
<td>RECEIVE_SMS</td>
<td>允许应用程序接收、监控、处理短信的权限</td>
</tr>
<tr>
<td>RECORD_AUDIO</td>
<td>允许应用程序录音的权限</td>
</tr>
<tr>
<td>SEND_SMS</td>
<td>允许应用程序发送短信的权限</td>
</tr>
<tr>
<td>SET_ORIENTATION</td>
<td>允许应用程序旋转屏幕的权限</td>
</tr>
<tr>
<td>SET_TIME</td>
<td>允许应用程序设置时间的权限</td>
</tr>
<tr>
<td>SET_TIME_ZONE</td>
<td>允许应用程序设置时区的权限</td>
</tr>
<tr>
<td>SET_WALLPAPER</td>
<td>允许应用程序设置桌面壁纸的权限</td>
</tr>
<tr>
<td>VIBRATE</td>
<td>允许应用程序控制震动的权限</td>
</tr>
<tr>
<td>WRITE_CONTACTS</td>
<td>允许应用程序写入用户联系人的权限</td>
</tr>
<tr>
<td>WRITE_HISTORY_BOOKMARKS</td>
<td>允许应用程序写历史书签的权限</td>
</tr>
<tr>
<td>WRITE_OWNER_DATA</td>
<td>允许应用程序写用户数据的权限</td>
</tr>
<tr>
<td>WRITE_SMS</td>
<td>允许应用程序写短信的权限</td>
</tr>
</tbody>
</table>
<h2 id="Android应用的基本组件介绍"><a href="#Android应用的基本组件介绍" class="headerlink" title="Android应用的基本组件介绍"></a>Android应用的基本组件介绍</h2><h3 id="Activity和View"><a href="#Activity和View" class="headerlink" title="Activity和View"></a>Activity和View</h3><ul>
<li>Activity<ul>
<li>Android应用中负责与用户交互的组件，通过setContentView(View)来显示指定组件</li>
<li>Activity是Window的容器，Activity包含一个getWindow()方法，返回该Acitivty所包含的窗口</li>
<li>Activity包含一个setTheme(int resid)方法来设置其窗口风格。如是否显示ActionBar，以对话框形式显示窗口</li>
</ul>
</li>
<li>View是所有UI控件、容器控件的基类，是用户实实在在看到的部分</li>
</ul>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service通常位于后台运行，一般不与用户交互，与Activity的地位并列。</p>
<h3 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><p>类似于事件编程的监听器，不同之处在于BroadcastReceiver监听的事件源是Android应用中的其他组件</p>
<p>实现流程大致如下：</p>
<ul>
<li>实现BroadcastReceiver子类，重写onReceive(Context context,Intent intent)</li>
<li>注册系统级的“事件监听器”（两种方式）<ul>
<li>Java代码中通过Context.registerReceiver()方法注册BroadcastReceiver</li>
<li>AndroidManifest.xml文件中使用<code>&lt;receiver.../&gt;</code>元素完成注册</li>
</ul>
</li>
<li>当其他组件通过sentBroadcast()/sendStickyBroadcast()/sendOrderedBroadcast()方法发送广播消息，如果该BroadcastReceiver也对该消息感兴趣(IntentFilter过滤)，onReceive(Context context,Intent intent)方法将会被触发</li>
</ul>
<h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>Android应用之间是相互独立的，应用可以通过ContentProvider向其他应用提供一些可以暴露的数据接口，以实现多个应用程序之间的数据交换。</p>
<p>ContentProvider需要实现以下抽象方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>insert(Uri,ContentValues)</td>
<td>向ContentProvider插入数据</td>
</tr>
<tr>
<td>delete(Uri,ContentValues)</td>
<td>删除ContentProvider中指定数据</td>
</tr>
<tr>
<td>update(Uri,ContentValues,String,String[])</td>
<td>更新ContentProvider中指定数据</td>
</tr>
<tr>
<td>query(Uri,String[],String,String[],String)</td>
<td>从ContentProvider查询数据</td>
</tr>
</tbody>
</table>
<p>通常ContentProvider需要结合ContentResolver一起使用，一个应用程序使用ContentProvider暴露自己的数据，而另一个通过ContentResolver来访问数据</p>
<h3 id="Intent和IntentFilter"><a href="#Intent和IntentFilter" class="headerlink" title="Intent和IntentFilter"></a>Intent和IntentFilter</h3><p>Intent是Android应用内不同组件之间通信的载体</p>
<table>
<thead>
<tr>
<th>效果</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>启动 Activity</code></td>
<td>调用<code>Context</code>的<code>startActivity(Intent intent)</code>/<code>startActivityForResult(Intent intent, int requestCode)</code>，向Intent中封装好指定Activity信息来启动Activity</td>
</tr>
<tr>
<td><code>启动 Service</code></td>
<td>调用<code>Context</code>的<code>startService(Intent intent)</code>/<code>bindService(Intent service,ServiceConnetion conn, int flags)</code>，向Intent中封装好指定Service信息来启动Service</td>
</tr>
<tr>
<td><code>触发 BroadcastReceiver</code></td>
<td>调用<code>Context</code>的<code>sendBroadcast(Intent intent)</code>/<code>sendStickyBroadcast(Intent intent)</code>/<code>sendOrderedBroadcast(Intent intent, String receiverPermission)</code>方法来发送广播消息，Intent封装了触发目标BroadcastReceiver的信息</td>
</tr>
</tbody>
</table>
<ul>
<li>显式Intent：明确指定需要启动或者触发的组件的类名</li>
<li>隐式Intent：指定需要启动或者触发的组件满足怎样的条件(Intent Filter)</li>
</ul>
<h2 id="签名Android应用程序"><a href="#签名Android应用程序" class="headerlink" title="签名Android应用程序"></a>签名Android应用程序</h2><p>签名的作用：</p>
<ul>
<li>确定发布者的身份。</li>
<li>确保应用的完整性。</li>
</ul>
<h3 id="使用Android-Studio对-Android-应用签名"><a href="#使用Android-Studio对-Android-应用签名" class="headerlink" title="使用Android Studio对 Android 应用签名"></a>使用Android Studio对 Android 应用签名</h3><p>单击菜单中的 Build -&gt; Generate Signed APK 选择需要打包的Module</p>
<p><img src="/2018/03/13/《疯狂Android讲义》读书笔记（一）/android-signature-step-1.png" alt="Signature Step 1"></p>
<p>首次创建签名需要新建一个存放Key的地址Key Store Path</p>
<p><img src="/2018/03/13/《疯狂Android讲义》读书笔记（一）/android-signature-step-2.png" alt="Signature Step 2"></p>
<p>设置Key Store的密码</p>
<p><img src="/2018/03/13/《疯狂Android讲义》读书笔记（一）/android-signature-step-3.png" alt="Signature Step 3"></p>
<p>设置Key 的相关参数和密码</p>
<p><img src="/2018/03/13/《疯狂Android讲义》读书笔记（一）/android-signature-step-4.png" alt="Signature Step 4"></p>
<p>选择apk生成的地址、类型(release/debug)，点击Finish生成Apk</p>
<p><img src="/2018/03/13/《疯狂Android讲义》读书笔记（一）/android-signature-step-5.png" alt="Signature Step 5"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/25/《鸟哥的Linux私房菜：基础学习篇》读书笔记（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老易的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/25/《鸟哥的Linux私房菜：基础学习篇》读书笔记（一）/" itemprop="url">《鸟哥的Linux私房菜：基础学习篇》读书笔记（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-25T14:53:42+08:00">
                2018-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第零章-计算机概论"><a href="#第零章-计算机概论" class="headerlink" title="第零章 计算机概论"></a>第零章 计算机概论</h1><h2 id="计算机：辅助人脑的好工具"><a href="#计算机：辅助人脑的好工具" class="headerlink" title="计算机：辅助人脑的好工具"></a>计算机：辅助人脑的好工具</h2><p>计算机的定义：</p>
<blockquote>
<p>接收使用者输入指令与数据，经由中央处理器的数字与逻辑单元运算处理后，以产生或储存有用的信息。</p>
</blockquote>
<h3 id="计算机硬件的五大单元"><a href="#计算机硬件的五大单元" class="headerlink" title="计算机硬件的五大单元"></a>计算机硬件的五大单元</h3><p>计算机的组成部分：</p>
<ul>
<li>输入单元：键盘、鼠标、读卡器、扫描仪、手写板、触摸屏等；</li>
<li>主机部分：系统单元，被主机机壳保护住了，里面含有 CPU 与主内存等；</li>
<li>输出单元：屏幕、打印机等</li>
</ul>
<p>中央处理器(Central Processing Unit, CPU)</p>
<blockquote>
<p>CPU 为一个具有特定功能的芯片， 里头含有微指令集。主要功能在于管理和运算。</p>
</blockquote>
<p>CPU 分为两个主要单元：</p>
<ul>
<li>算数逻辑单元：主要负责程序运算与逻辑判断</li>
<li>控制单元：主要在协调周边各组件与个单元间的工作</li>
</ul>
<p>CPU 处理数据流流向</p>
<blockquote>
<p>输入单元-&gt;主内存-&gt;CPU-&gt;主内存-&gt;输出单元</p>
</blockquote>
<p>计算机的五大单元：</p>
<ul>
<li>输入单元</li>
<li>输出单元</li>
<li>CPU 控制单元</li>
<li>CPU 算数与逻辑单元</li>
<li>主内存</li>
</ul>
<h3 id="CPU-的种类"><a href="#CPU-的种类" class="headerlink" title="CPU 的种类"></a>CPU 的种类</h3><ul>
<li>精简指令集(Reduced Instruction Set Computer, RISC)<ul>
<li>指令集精简，指令执行时间短，完成的动作单纯，效率高；</li>
<li>复杂工作需要多个指令来完成；</li>
<li>常见的 RISC CPU：<ul>
<li>SUN 公司的SPARC系列：学术领域的大型工作站、银行金融体系的主要服务器</li>
<li>IBM 公司的 Power Architecture (包括 Power PC )系列 Sony公司的 Play Station 系列主机</li>
<li>ARM 各厂牌手机、导航、PDA、交换机、路由器等</li>
</ul>
</li>
</ul>
</li>
<li>复杂指令集(Complex Instruction Set Computer, CISC)<ul>
<li>每条指令可以执行一些比较底层的硬件操作，指令数目多且复杂，长度并不相同，花费时间长，处理的工作较为丰富；</li>
<li>常见的 CISC CPU 主要由 Intel AMD VIA 等x86架构的CPU<ul>
<li>x86 架构<ul>
<li>由于Intel最初开发的 CPU 代号是 8086 ，后来依据此架构相继生产的代号分别是80286，80386…等，所以这种架构就被称为 x86 架构了</li>
</ul>
</li>
<li>x86_64 架构<ul>
<li>由 AMD 公司在之前 Intel 的8位、16位和32位的基础上改进升级为64位，为了区别两者差异所以改名为 x86_64</li>
</ul>
</li>
<li>区别<ul>
<li>CPU 整体结构：如二级缓存，每次运作可执行的命令数</li>
<li>微指令集的不同：x86_64 架构大多含有更先进的指令集，可以加速多媒体的运行，也能加强虚拟化的性能，而且某些指令集可以降低 CPU 功耗。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="周边设备"><a href="#周边设备" class="headerlink" title="周边设备"></a>周边设备</h3><p>单有CPU无法运行计算机，还需要其他周边的设备才能进行实际的操作。周边设备中最重要的是主板，通过主板可以将CPU与各个设备连接起来。</p>
<p>其他重要的设备还有：</p>
<ul>
<li>系统单元：包括CPU与内存及主板相关原件</li>
<li>存储单元：内存(main memory, RAM)与辅助内存，辅助内存包括硬盘，软盘、光盘、磁带等。</li>
<li>输入输出单元：同时涵盖输入输出功能的设备目前主要由触摸显示屏。单纯输入设备</li>
</ul>
<h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><p>将一个电脑比作人体</p>
<ul>
<li>CPU = 脑袋：每个人会做的事情不一样（微指令集的差异），但主要都是通过脑袋来判断和控制身体各部分的活动的</li>
<li>主内存 = 脑袋中的记录区块：实际活动过程中，脑袋能将和外界的互动暂时j记录下来，提供给 CPU 来进行运算</li>
<li>硬盘 = 脑袋中的记忆区块：将重要的数据记录下来以便下次继续使用</li>
<li>主板 = 神经系统：将所有的组件连接起来，在 CPU 发出命令后传达到各个组件进行活动</li>
<li>各项周边设备 = 人体与外界沟通的手、脚、皮肤、眼睛等：与外界互动的关键</li>
<li>显卡 = 脑袋中的影像：将来自眼睛的信号传达到脑袋中呈现所以显卡的数据也是由CPU控制的</li>
<li>电源 = 心脏：所有的组件要能运作得要有足够的电力供给才行</li>
</ul>
<h3 id="计算机分类"><a href="#计算机分类" class="headerlink" title="计算机分类"></a>计算机分类</h3><ul>
<li>超级计算机</li>
<li>大型计算机</li>
<li>迷你计算机</li>
<li>工作站</li>
<li>微计算机</li>
</ul>
<h3 id="计算机上常用的计算单位"><a href="#计算机上常用的计算单位" class="headerlink" title="计算机上常用的计算单位"></a>计算机上常用的计算单位</h3><ul>
<li>容量单位 K M G T P</li>
<li>速度单位 Hz</li>
</ul>
<h2 id="个人计算机架构与周边设备"><a href="#个人计算机架构与周边设备" class="headerlink" title="个人计算机架构与周边设备"></a>个人计算机架构与周边设备</h2><p>作为PC界两大CPU巨头，Intel和AMD在CPU的架构设计上有所不同，所以其对应的芯片组结构也会有差异</p>
<ul>
<li><p>Intel CPU 芯片组</p>
<ul>
<li>北桥：负责连接速度较快的CPU内存和显卡等组件，现在几乎所有的北桥（Intel/AMD）都集成在CPU上。</li>
<li>南桥：负责连接速度较慢的设备如硬盘U盘网卡等</li>
</ul>
</li>
</ul>
<p><img src="/2018/02/25/《鸟哥的Linux私房菜：基础学习篇》读书笔记（一）/x99-chipset-block-diagram.jpg" alt="Intel x99 架构芯片组"></p>
<ul>
<li>AMD CPU 芯片组</li>
</ul>
<blockquote>
<p>AMD与Intel芯片组的架构的区别在于内存直接与CPU沟通而不通过北桥，加速了CPU与内存的沟通</p>
</blockquote>
<p><img src="/2018/02/25/《鸟哥的Linux私房菜：基础学习篇》读书笔记（一）/AMD-chipset-architecture.jpg" alt="AMD 架构芯片组"></p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><blockquote>
<p>CPU的频率：每秒钟CPU可以工作的次数</p>
</blockquote>
<ul>
<li>CPU的“外频”与“倍频”<ul>
<li>外频：CPU与外部组件进行传输的速度</li>
<li>倍频：CPU内部用来加速性能的倍数</li>
<li>CPU频率：外频与倍频相乘才是CPU的频率</li>
<li>关于超频：CPU倍频在出厂时被锁定，发烧玩家可以通过改变主板参数来调整CPU的外频来达到超频的效果</li>
</ul>
</li>
</ul>
<blockquote>
<p>现在Intel的CPU会主动进行超频的工作，通过Intel的turbo技术，在需要大量运算需求时进行超频，在运算需求较低时会降频。</p>
</blockquote>
<ul>
<li>32位与64位的CPU与“总线宽度”<ul>
<li>系统总线：北桥的系统总线，传输速度较快</li>
<li>I/O总线：南桥的系统总线，主要联系硬盘、USB、网卡等设备</li>
<li>总线宽度：现在一般分为32位和64位</li>
<li>前端系统总线速度(Front Side Bus,FSB)：北桥支持的频率，FSB*总线宽度即每秒传输的最大数据量。</li>
<li>字长(Word Size)：CPU单次能够处理的数据的大小，分为32位和64位。</li>
</ul>
</li>
</ul>
<blockquote>
<p>现在我们所说的32位和64位计算机说的都是CPU的字长。而由于字长的限制，32位计算机能从内存传来的数据量有限，这就是为什么32位的系统最多只支持4GB内存的原因了。</p>
<p>CPU的字长也可以和总线宽度不一致，例如在32位CPU的时期也可以设计出总线宽度位64位的芯片组，但还是称之为32位CPU。</p>
</blockquote>
<ul>
<li>CPU等级<ul>
<li>i586等级：Intel Pentium MMX与AMD K6时代的CPU</li>
<li>i686等级：Intel Celeron与AMD Athlon(K7)时代之后的32位CPU</li>
<li>x86_64等级：目前的64位CPU统称</li>
</ul>
</li>
</ul>
<blockquote>
<p>目前很多程序都有对CPU做最优化的设计，比如x86_64可以安装586的软件（向下兼容），但x86_64的应用程序不能装载868等级以下的电脑中。</p>
</blockquote>
<ul>
<li>超线程<ul>
<li>原理：CPU在执行单线程任务时，并不是核心内的每一个单元都在工作，超线程技术就是让那些闲置的执行单元去另一个线程工作。</li>
<li>实现：每个CPU内部将重要的寄存器(register)分成两群，而让程序分别使用这两群寄存器。也就是说，可以有两个程序“同时竞争CPU的运算单元”，而非通过操作系统的多任务切换。</li>
</ul>
</li>
</ul>
<blockquote>
<p>超线程的初衷是为了提高运算性能，但在有些情况下可能会导致性能降低。</p>
</blockquote>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><blockquote>
<p>个人电脑内存的主要组件为动态随机访问内存(Dynaimic Random Access Memory,DRAM)</p>
</blockquote>
<ul>
<li>双通道设计：北桥总线宽度目前一般最多达到64位，启用双通道设计同时插入两个型号详尽的内存可以让北桥的总线宽度翻倍达到128位，这就是双通道设计的理念。</li>
</ul>
<blockquote>
<p>服务器所需要的速度更快，因此除了双通道之外，中介服务器也经常提供三通道甚至四通道的内存环境</p>
</blockquote>
<ul>
<li>CPU频率与内存的关系：理论上应选择CPU频率与内存外频一致，但由于技术提升可能会产生不一致的情况，此时应保持CPU的外频与内存外频一致。</li>
<li>DRAM与SRAM<ul>
<li>二级缓存(L2 cache)：整合在CPU内，存储一些常用的数据，CPU如果需要使用就不需要通过北桥，速度和性能会大大提高。</li>
<li>静态随机访问存储器(Static Random Access Memory)：常用的DRAM访问速度不够满足二级缓存的读写速度，SRAM通过其大规模的晶体管电路可以很好解决这个问题</li>
</ul>
</li>
<li>只读内存(Read Only Memory, ROM)<ul>
<li>CMOS(互补式金属氧化物半导体)：在主板上用于记录各个组件的控制参数，需要借助一颗电池提供电源来保留参数。</li>
<li>BIOS(Basic Input Output System)：是一套写死在主板只读内存(Read Only Memory, ROM)上的程序，这套程序负责向CMOS读取和写入相关信息。</li>
<li>固件(firmware)很多也是使用ROM来进行软件的写入的。固件像软件一样也是一个被电脑所执行的程序，然而他是对硬件内部而言更加重要的部分。例如BIOS就是一个固件，阮然对于我们日常操作没有太大关系，但它却控制着开机时各项硬件参数的取得。</li>
</ul>
</li>
</ul>
<blockquote>
<p>现在的BIOS为了更新方便，一般使用闪存(flash)或者EEPROM来取代CMOS。</p>
</blockquote>
<h3 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h3><ul>
<li>显卡用于处理图形的显示，重点在于解析度和色彩的深度</li>
<li>显卡内存：每个图像都会占用一定的内存，所以在显卡上也会有一定大小的内存，内存大小影响最终的屏幕解析度和色彩深度</li>
<li>GPU：早期的图像处理是交给CPU进行运算的，但由于3D、VR的流行，显卡的运算能力也越来越重要，所以在显卡中也会有一个专门的运算单元来处理图形图像，这就是GPU</li>
<li>PCIe：用于连接显卡与北桥的接口标准。使用类似管线的概念来处理，在PCIe第一版中，每条管线可以具有250MBytes/s的贷款性能，管线越多(通常涉及到x16管线)则总带宽越高。</li>
</ul>
<h3 id="硬盘与存储设备"><a href="#硬盘与存储设备" class="headerlink" title="硬盘与存储设备"></a>硬盘与存储设备</h3><ul>
<li>硬盘的物理组成<ul>
<li>磁盘</li>
<li>磁头(Head)</li>
<li>盘片转轴及控制电机</li>
<li>磁头控制器</li>
<li>数据转换器</li>
<li>接口</li>
<li>缓存</li>
</ul>
</li>
</ul>
<p><img src="/2018/02/25/《鸟哥的Linux私房菜：基础学习篇》读书笔记（一）/hard-drive-structure.jpg" alt="硬盘结构"></p>
<ul>
<li>磁盘上的数据<ul>
<li>磁道：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道（Track）。</li>
<li>柱面：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面（Cylinder）。</li>
<li>扇区：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区（Sector），每个扇区的大小都是512Bytes，也有大容量硬盘设计成4KByte的扇区。硬盘的第一个扇区，叫做<a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA" target="_blank" rel="noopener">引导扇区</a>。</li>
<li>硬盘大小计算公式</li>
</ul>
</li>
</ul>
<blockquote>
<p>磁头数量 <em> 每个header负责的磁柱数量 </em> 每个磁柱所含有的磁区数量 * 磁区的容量</p>
</blockquote>
<p><img src="/2018/02/25/《鸟哥的Linux私房菜：基础学习篇》读书笔记（一）/disk-structure.png" alt="磁盘结构"></p>
<ul>
<li><p>数据接口</p>
<ul>
<li>(ATA)IDE接口：全称Advanced Technology Attachment，是用传统的40-pin并口数据线连接主板与硬盘的，接口速度最大为133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被SATA所取代。</li>
<li>SATA接口：全称Serial ATA，也就是使用串口的ATA接口，因抗干扰性强，且对数据线的长度要求比ATA低很多，支持热插拔等功能，SATA-II的接口速度为300MiB/s，而新的SATA-III标准可达到600MiB/s的传输速度。SATA的数据线也比ATA的细得多，有利于机箱内的空气流通，整理线材也比较方便。</li>
<li>SCSI接口：全称是Small Computer System Interface（小型机系统接口），经历多代的发展，从早期的SCSI-II，到目前的Ultra320 SCSI以及Fiber-Channel（光纤通道），接口型式也多种多样。SCSI硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速15000rpm的高转速，且资料传输时CPU占用率较低，但是单价也比相同容量的ATA及SATA硬盘更加昂贵。</li>
<li>SAS接口：全称Serial Attached SCSI，是新一代的SCSI技术，和SATA硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到6Gb/s。此外也透过缩小连接线改善系统内部空间等</li>
<li>FC接口：全称Fibre Channel，光纤通道接口。拥有此接口的硬盘在使用光纤联接时具有热插拔性、高速带宽（4Gb/s或10Gb/s）、远程连接等特点；内部传输速率也比普通硬盘更高。限制于其高昂的售价，通常用于高端服务器领域。</li>
<li>USB接口：最常见的外接式接口，传输速度较慢，实际读写速度（USB3.0/3.1）只有100MBytes/s左右。</li>
<li>固态硬盘(Solid State Disk, SSD)<ul>
<li>读写速度快，不需要马达转动，直接通过内存直接读写，没有数据延迟</li>
<li>省电</li>
<li>有写入次数限制，通常寿命大概两年</li>
<li>使用被封或者是RAID机制来防止SSD损毁</li>
</ul>
</li>
</ul>
</li>
<li><p>选购与转运须知</p>
<ul>
<li>容量：这个不用说了。</li>
<li>缓存：硬盘上头含有一个缓冲内存，这个内存主要可以将硬盘内常使用的数据缓存起来，以加速系统的读取效能。 通常这个缓冲内存越大越好，因为缓冲内存的速度要比数据从硬盘盘中被找出来要快的多了！</li>
<li>转速：因为硬盘主要是利用主轴马达转动磁碟盘来存取，因此转速的快慢会影响到效能。 主流的桌上型计算机硬盘为每分钟7200转，笔记型计算机则是5400转。有的厂商也有推出高达10000转的硬盘， 若有高效能的数据存取需求，可以考虑购买高转速硬盘。（当然，如果使用SSD硬盘就无需考虑转速）</li>
<li>转运须知：由於硬盘内部机械手臂上的磁头与硬盘盘的接触是很细微的空间， 如果有抖动或者是脏污在磁头与硬盘盘之间就会造成数据的损毁或者是实体硬盘整个损毁～ 因此，正确的使用计算机的方式，应该是在计算机通电之后，就绝对不要移动主机，并免抖动到硬盘， 而导致整个硬盘数据发生问题啊！另外，也不要随便将插头拔掉就以为是顺利关机！因为机械手臂必须要归回原位， 所以使用操作系统的正常关机方式，才能够有比较好的硬盘保养啊！因为他会让硬盘的机械手臂归回原位啊！</li>
</ul>
</li>
</ul>
<h3 id="扩展卡与接口"><a href="#扩展卡与接口" class="headerlink" title="扩展卡与接口"></a>扩展卡与接口</h3><ul>
<li>当前主要的扩展接口标准为PCIe，具有带宽高的优点，几乎现在所有的主板上都使用PCIe接口标准的扩展卡，也会保留PCI插槽以向下兼容。</li>
<li>现在的主板通常已经整合了相当多的设备了包括声卡、网卡、USB控制卡、网卡、磁盘阵列卡等。</li>
<li>PCIe有不同的通道数，基本上常见的就是x1,x4,x8,x16等，个人主板常见的是x16。中级服务器大多有多个x8接口，x16反而少见。</li>
<li>多信道卡(如x8卡)安装在少信道插槽(如x4)的可用性<ul>
<li>CPU对多仅能支持16个PCIe3.0的信道数</li>
<li>有些主板设计有3个x16的插槽，前面一个是CPU支持的，后面两个是南桥提供的PCIe2.0的接口</li>
<li>后面两个x16插槽只有x8或x4的通道数，其他都是空的，如果在这里插入x16卡，则只能满足其实际通道数的性能。</li>
</ul>
</li>
</ul>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><ul>
<li><p>发挥扩展卡性能需考虑的插槽位置</p>
<ul>
<li>在安插卡时需要阅读主板的逻辑示意图，把带宽需求大的卡插入直接与CPU相连的插槽，贷款需求量相对较小的卡插入与南桥相连的插槽</li>
</ul>
</li>
<li><p>设备I/0地址与中断请求(Interupt request, IRQ)</p>
<ul>
<li>I/O地址：类似于设备的门牌号码，每个设备都有自己的地址，一般来说不能有两个设备使用同一个I/O地址。</li>
<li>中断请求(Interupt request, IRQ)：按照上面的比喻，IRQ相当于各个门派连接到邮件中心(CPU)的专门路径。各个设备可以通过IRQ中断信道来告知CPU该设备的工作情况，可以方便CPU进行工作分配的任务。</li>
</ul>
</li>
<li><p>CMOS与BIOS</p>
<ul>
<li>CMOS：主要的功能为记录主板上的重要参数，包括系统时间、CPU电压频率、各项设备的I/O地址与IRQ等，由于这些数据的记录要花费电力，所以在主板上才有电池。</li>
<li>BIOS：为写入到主板上某一块flash或EEPROM的程序，它可以在开机的时候执行，用于载入CMOS当中的参数，并尝试调用储存设备中的开机程序，进一步进入操作系统。<blockquote>
<p>BIOS也可以修改CMOS中的数据。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>连接周边设备的接口</p>
<ul>
<li>PS/2接口：元贝常见的键盘和鼠标的接口，不过目前逐渐被USB取代。</li>
<li>USB接口：目前只剩下USB2.0余USB3.0，为了方便区分，USB3.0为蓝色接口。</li>
<li>声音输入输出与麦克风</li>
<li>RJ-45网口</li>
<li>HDMI：用于高清影像与声音传输</li>
</ul>
</li>
</ul>
<h2 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h2><h3 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h3><ul>
<li>二进制</li>
<li>十进制</li>
<li>八进制</li>
<li>十六进制</li>
</ul>
<h3 id="文字编码系统"><a href="#文字编码系统" class="headerlink" title="文字编码系统"></a>文字编码系统</h3><ul>
<li>计算机上储存数据都是用0与1表示，如果想要让他显示文字，需要通过编码系统(字码对照表)</li>
<li>当文字陷入文件时，会先把文字按照编码对照表转成数字之后再进行保存，屏幕上出现的乱码是因为编码对照表的翻译出错导致产生的误差</li>
<li>常用的英文编码表为ASCII系统，每个符号(英文、数字或符号)都会占用1Bytes的空间，因此会有2^8=256种变化</li>
<li>中文的编码系统早起最常用的就是big5编码表（繁体中文），每个中文字占用2Bytes，理论上最多可以有2^16=65526个中文字。但是因为并不是所有的位都拿来对应中文，所以实际并不能达到这么多。目前big5之定义了一万三千多个中文字，所以很多中文是无法显示的。</li>
<li>国际组织ISO/IEC制定了Unicode编码系统(UTF-8)，这个编码系统打破了所有国家的不同编码。</li>
</ul>
<h2 id="软件程序运行"><a href="#软件程序运行" class="headerlink" title="软件程序运行"></a>软件程序运行</h2><h3 id="机器程序与编译程序"><a href="#机器程序与编译程序" class="headerlink" title="机器程序与编译程序"></a>机器程序与编译程序</h3><ul>
<li>需要交代CPU工作任务就需要参考它的微指令集内容，撰写CPU能读懂的指令码，这样CPU就能运行，不过这样的流程有几个麻烦的地方：<ul>
<li>需要了解机器语言：机器只认识0与1，因此必须要直接写给机器看，非常难！</li>
<li>了解所有硬件的相关功能函数：因为程序必须要写给机器看，当然就要参考机器本身，针对功能写程序码。</li>
<li>程序不具有便携性：每个CPU都具有独特的微指令集，同样，每个硬件都有其功能函数。因此在A电脑上写的程序，理论上是没有办法在B电脑上运行的。况且程序码是非常难修改的。</li>
<li>程序具有专一性：程序必须要针对硬件功能函数来撰写，如果已经开发了一个浏览器程序，想要在开发文件管理程序，还是得从头参考硬件功能函数撰写。</li>
</ul>
</li>
<li>为了解决这几个问题，设计出了高级语言以及编译器来把语言翻译成机器语言。</li>
</ul>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul>
<li>操作系统(Operating System)与内核(Kernel)<ul>
<li>操作系统(Operating System, OS)：是一组程序，用于管理电脑的所有活动以及驱动系统中的所有硬件，硬件的所有动作都必须要通过操作系统来完成。</li>
<li>内核(Kernel)：也是一组程序，主要管控硬件与提供相关的能力(例如存取硬盘、网络功能、CPU资源获取等)。</li>
<li>内核程序放置在内存中的区块是受保护的，并且开机后就一直常驻在内存当中。如果使用者不小心将内核程序停止或破坏，将会导致整个系统崩溃。</li>
</ul>
</li>
<li>系统调用(System Call)<ul>
<li>操作系统提供了一整组的开发接口(系统调用层)给工程师来开发软件，工程师只需要遵守开发接口即可，不用再根据核心的函数来进行开发了</li>
<li>一些概念<ul>
<li>操作系统的内核层直接参考硬件规格写成，所以同一个操作系统不能够在不一样硬件架构下运行。举个例子：个人版Windows8.1系统不能直接在ARM架构的电脑下运行。</li>
<li>操作系统知识在管理整个硬件资源，包括CPU、内存、输入输出设备以及文件系统文件。如果没有其他的应用程序辅助，操作系统只能让电脑主机准备就绪(Ready)而已。</li>
<li>应用程序的开发都是参考操作系统提供的开发接口，所以应用程序只能在该操作系统上运行，不能在其他操作系统上运行。</li>
</ul>
</li>
<li>内核功能<ul>
<li>系统调用接口(System call interface)：为了方便程序开发者开一轻易地通过与核心的沟通，将硬件的资源进一步利用。</li>
<li>程序管理(Process control)：内核必须要能够控制多个任务环境下CPU资源的有效分配。另外，良好的CPU调度机制将会有效加快整体系统性能。</li>
<li>内存管理(Memory management)：内核控制整个系统的内存管理，通常内核会提供虚拟内存的功能，当内存不足时可以提供内存交换(swap)功能。</li>
<li>文件系统管理(Filesystem management)：内核长官文件系统，例如数据的输入输出等工作，以及不同文件格式的支持。</li>
<li>设备驱动(Device drivers)：硬件的管理是内核的主要工作之一，当然设备的驱动程序就是内核需要做的事情。</li>
</ul>
</li>
<li>操作系统与驱动程序<ul>
<li>操作系统必须要能旭东硬件，这样应用程序才能够使用该硬件功能；</li>
<li>一般来说，操作系统会提供开发接口，让开发商制作他们的驱动程序；</li>
<li>要使用新硬件功能，必须要安装厂商提供的驱动程序才行</li>
<li>驱动程序是由厂商提供的，与操作系统开发者无关</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h3><h2 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a>划重点</h2><ul>
<li>计算机的定义：“接收使用者输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或存储成游泳的信息”；</li>
<li>计算机的五大单元<ul>
<li>输入单元</li>
<li>输出单元</li>
<li>控制单元</li>
<li>算数逻辑单元</li>
<li>存储单元</li>
</ul>
</li>
<li>CPU占有控制、算数逻辑单元，存储单元包含内存与辅助内存；</li>
<li>CPU发出命令使数据流入/流出内存，而CPU实际要处理的数据则完全来自于内存；</li>
<li>CPU依设计理念主要分为：精简指令集(RISC)和复杂指令集(CISC)系统；</li>
<li>CPU的频率 = 外频 * 倍频<ul>
<li>外频：CPU与外部元件进行数据传输时的速度</li>
<li>倍频：CPU内部用来加速工作性能的倍数</li>
</ul>
</li>
<li>新的CPU设计中，已经将北桥的内存控制芯片整合到CPU内，而CPU与内存、显卡沟通的总线通常称为系统总线。南桥就是所谓的输入输出(I/O)总线，主要在连接硬盘、USB、网卡等周边设备；</li>
<li>CPU每次能够处理的数据量称为字长(word size)，字长大小依据CPU的设计而有32位和64位。我们现在所说的32位或64位电脑主要是依据CPU的字长而决定的；</li>
<li>个人电脑的内存主要部件为动态随机存取内存(Dynamic Random Access Memory, DRAM)，至于CPU内部的第二层告诉缓存则使用静态随机存取内存(Static Random Access Memory, SRAM)；</li>
<li>BIOS(Basic Input Output System)是一套程序，这套程序是写死到主板上的一个内存芯片中，这个内存在没有通电时也能保存数据，这个内存叫做只读存储器(Read Only Memory, ROM)。</li>
<li>目前主流的外接卡接口大多为PCIe接口；</li>
<li>常见的显卡连接到屏幕的接口有HDMI/DVI/D-Sub/Display port等等。HDMI可同时传送影像和声音；</li>
<li>传动硬盘的组成为：圆形盘片、机械手臂、磁头与主轴马达，其中盘片的组成为扇区、磁道与柱面；</li>
<li>磁盘连接到主板的接口大多为SATA或SAS;</li>
<li>常见的文字编码为ASCII，中文编码主要有Big5(繁体中文)和UTF-8(繁体中文和简体中文)，目前主流为UTF-8；</li>
<li>操作系统(Operating System, OS)其实也是一组程序，这组程序的终点在于管理电脑的所有活动以及驱动系统中的所有硬件；</li>
<li>电脑主要以二进制作为单位，常用的磁盘容量单位为Bytes，其换算公式为 1 Byte = 8bits</li>
<li>最纯净的操作系统尽在驱动与管理硬件，而要使用硬件时，就需要通过应用软件或者是壳程序(Shell)的功能来调用操作系统操作硬件工作。目前称为操作系统的，除了上述功能外，通常已经半酣了日常工作所需要的应用软件在内了。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/25/目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老易的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/25/目录/" itemprop="url">目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-25T14:50:36+08:00">
                2018-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>新的一年，新的懒惰。</p>
</blockquote>
<h1 id="日常操作，都坐下"><a href="#日常操作，都坐下" class="headerlink" title="日常操作，都坐下"></a>日常操作，都坐下</h1><blockquote>
<p>一些奇奇怪怪的技术贴</p>
</blockquote>
<ul>
<li><a href="https://yiguohan.github.io/2018/02/07/Mac%E6%94%BE%E5%9C%A8%E5%AE%B6%E5%90%83%E7%81%B0%EF%BC%9F%E6%9D%A5%E6%90%AD%E4%B8%AA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%90%A7%EF%BC%81/" target="_blank" rel="noopener">Mac放在家吃灰？来搭个静态博客吧！</a></li>
<li><a href="https://yiguohan.github.io/2018/04/10/Android%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/" target="_blank" rel="noopener">Android开发规范</a></li>
</ul>
<h1 id="正在读的书"><a href="#正在读的书" class="headerlink" title="正在读的书"></a>正在读的书</h1><blockquote>
<p>以下记录的是懒癌博主日常阅读的书籍的进度及其读书笔记：</p>
</blockquote>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul>
<li>《鸟哥的Linux私房菜：基础学习篇》(6%)<ul>
<li><a href="https://yiguohan.github.io/2018/02/25/%E3%80%8A%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">《鸟哥的Linux私房菜：基础学习篇》读书笔记(一)</a></li>
</ul>
</li>
</ul>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul>
<li>《Android开发艺术探索》(27.2%)</li>
<li>《疯狂Android讲义》(4.7%)<ul>
<li><a href="https://yiguohan.github.io/2018/03/13/《疯狂Android讲义》读书笔记（一）/" target="_blank" rel="noopener">《疯狂Android讲义》读书笔记（一）</a></li>
</ul>
</li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul>
<li>《Effective Java》</li>
</ul>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ul>
<li>《C++ Primer 中文版》（第 5 版）</li>
</ul>
<h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><blockquote>
<p>人间有真情，人间有真爱</p>
</blockquote>
<ul>
<li><a href="https://yiguohan.github.io/2018/01/30/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/" target="_blank" rel="noopener">写在前面</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/Mac放在家吃灰？来搭个静态博客吧！/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老易的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Mac放在家吃灰？来搭个静态博客吧！/" itemprop="url">Mac放在家吃灰？来搭个静态博客吧！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T15:43:34+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Geek-Style/" itemprop="url" rel="index">
                    <span itemprop="name">Geek Style</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>去年买了台 Macbook pro 2017 Touchbar version，美其名曰 Coding ，然而现在每天放在出租屋里吃灰，下班后也是偶尔看看 Youtube 和小姐姐们直播。</p>
<p>Android Studio 也是好久没有打开啦。</p>
<p>所以,今天懒癌博主就带大家来看看怎样变废为宝——在 Mac 上搭建基于 Node.js+Hexo+Github Pages 的静态博客。</p>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><ul>
<li><a href="https://www.apple.com/mac/" target="_blank" rel="noopener">Mac</a> 一台</li>
<li><a href="https://nodejs.org" target="_blank" rel="noopener">Node.js</a></li>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> ( Mac 自带)</li>
<li><a href="https://github.com" target="_blank" rel="noopener">GitHub</a> 账号</li>
</ul>
<h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h2><h3 id="2-1-打开-Terminal-输入以下命令："><a href="#2-1-打开-Terminal-输入以下命令：" class="headerlink" title="2.1 打开 Terminal 输入以下命令："></a>2.1 打开 Terminal 输入以下命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ su npm install hexo -g-cli</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Hexo官网给出的命令是 <code>$ npm install hexo -g-cli</code> 但是在 Mac OS 环境下如果不使用管理员权限 <code>su</code> 很可能会因为权限不足导致安装失败</p>
</blockquote>
<ul>
<li><code>su</code> 执行 Linux 管理员权限。</li>
<li><code>npm</code> <a href="https://zh.wikipedia.org/wiki/Npm" target="_blank" rel="noopener">Node Package Manager</a> 的简称，它随Node.js一起安装，用于执行 Node.js 依赖的管理命令</li>
<li><code>-g</code> 全局安装</li>
<li><code>-cli</code> 安装hexo命令行</li>
</ul>
<h3 id="2-2-在-Terminal-中使用-cd-命令进入到你想要存放网页资源的本地文件夹，输入以下命令，初始化资源文件夹："><a href="#2-2-在-Terminal-中使用-cd-命令进入到你想要存放网页资源的本地文件夹，输入以下命令，初始化资源文件夹：" class="headerlink" title="2.2 在 Terminal 中使用 cd 命令进入到你想要存放网页资源的本地文件夹，输入以下命令，初始化资源文件夹："></a>2.2 在 Terminal 中使用 cd 命令进入到你想要存放网页资源的本地文件夹，输入以下命令，初始化资源文件夹：<br></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure>
<ul>
<li><code>init</code> 在当前所在文件夹中进行hexo初始化</li>
<li><code>blog</code> 在当前路径下会生成一个名为 blog 的文件夹来存放 hexo 的相关资源文件，当然你也可以取其他的名字</li>
</ul>
<h3 id="2-3-等待初始化完成后，使用-cd-命令进入刚刚生成的-blog-文件夹中，输入以下命令，在当前路径下安装模板依赖："><a href="#2-3-等待初始化完成后，使用-cd-命令进入刚刚生成的-blog-文件夹中，输入以下命令，在当前路径下安装模板依赖：" class="headerlink" title="2.3 等待初始化完成后，使用 cd 命令进入刚刚生成的 blog 文件夹中，输入以下命令，在当前路径下安装模板依赖："></a>2.3 等待初始化完成后，使用 cd 命令进入刚刚生成的 blog 文件夹中，输入以下命令，在当前路径下安装模板依赖：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>安装完成后，从本地运行 Hexo Server 加载网页查看效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>等待部署完成后，打开浏览器地址输入 <a href="https://localhost:4000" target="_blank" rel="noopener">https://localhost:4000</a> 即可看到如下页面：</p>
<p><img src="/2018/02/07/Mac放在家吃灰？来搭个静态博客吧！/helloHexo.jpg" alt="&quot;HelloHexo&quot;"></p>
<h2 id="3-关联-GitHub"><a href="#3-关联-GitHub" class="headerlink" title="3. 关联 GitHub"></a>3. 关联 GitHub</h2><h3 id="3-1-添加-SSH-Key-到-GitHub"><a href="#3-1-添加-SSH-Key-到-GitHub" class="headerlink" title="3.1 添加 SSH Key 到 GitHub"></a>3.1 添加 SSH Key 到 GitHub</h3><h4 id="3-1-1-什么是SSH-Key"><a href="#3-1-1-什么是SSH-Key" class="headerlink" title="3.1.1 什么是SSH Key"></a>3.1.1 什么是SSH Key</h4><p>因为本文的重点不是SSH，所以我就不在这里赘述了。大概的意思呢就是我这里有一把钥匙(私钥)，GitHub 也有一把(公钥)，这是我和 GitHub 进行 PY 交易的暗号。当然这里叙述的比较简单片面，如果你对SSH感兴趣，不妨看看这两篇博客：</p>
<p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">阮一峰的网络日志 SSH原理与运用（一）：远程登录</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="noopener">阮一峰的网络日志 SSH原理与运用（二）：远程操作与端口转发</a></p>
<h4 id="3-1-2-检查本地是否存在-SSH-Key"><a href="#3-1-2-检查本地是否存在-SSH-Key" class="headerlink" title="3.1.2 检查本地是否存在 SSH Key"></a>3.1.2 检查本地是否存在 SSH Key</h4><p>打开 Terminal 输入并执行以下命令，列出所有文件夹中以 <code>.ssh</code> 结尾的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>
<p>如果列表中存在 <code>id_rsa.pub</code> 或 <code>id_dsa.pub</code> 文件，则可以直接调到到下面的步骤，如果不存在，就接着往下看</p>
<h4 id="3-1-3-生成SSH-Key"><a href="#3-1-3-生成SSH-Key" class="headerlink" title="3.1.3 生成SSH Key"></a>3.1.3 生成SSH Key</h4><p>在 Terminal 中输入并执行一下命令，在本地生成新的公钥/密钥对，注意这里的 <a href="mailto:`your_email@email.com" target="_blank" rel="noopener">`your_email@email.com</a>` 要换成你自己的 git 用户名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@email.com&quot;</span><br></pre></td></tr></table></figure>
<p>这样，系统会帮你生成一对密钥 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 。</p>
<h4 id="3-1-4-在GitHub上添加SSH-Key"><a href="#3-1-4-在GitHub上添加SSH-Key" class="headerlink" title="3.1.4 在GitHub上添加SSH Key"></a>3.1.4 在GitHub上添加SSH Key</h4><ul>
<li><p>Finder 前往默认的 生成地址 <code>~/.ssh/id_rsa.pub</code> 打开文件，复制其中的所有数据。</p>
</li>
<li><p>登陆 GitHub 前往 Settings -&gt; SSH and GPG Keys -&gt; 点击 SSH Keys 标题旁边的 New SSH Key 按钮</p>
</li>
<li><p>在Title中输入任意你认为可以标记的信息，在Key中粘贴刚才在本地.pub文件中复制的信息，点击 Add SSH Key 按钮。</p>
</li>
</ul>
<h3 id="3-2-在GitHub上创建仓库"><a href="#3-2-在GitHub上创建仓库" class="headerlink" title="3.2 在GitHub上创建仓库"></a>3.2 在GitHub上创建仓库</h3><ul>
<li>登陆GitHub 点击New Repository</li>
<li>仓库名称 <code>username.github.io</code> (注意：此处的 <code>username</code> 改为你的 GitHub 用户名，并且只能是你的用户名，否则无法将网页托管在 GitHub Page 上。同时，每个 GitHub 账号只能在 GitHub Page上申请一个域名)</li>
<li>勾选 <code>Initialize this repository with a README</code></li>
<li>点击 <code>Create repository</code> 创建仓库</li>
</ul>
<h3 id="3-3-将本地的Hexo文件更新到GitHub仓库"><a href="#3-3-将本地的Hexo文件更新到GitHub仓库" class="headerlink" title="3.3 将本地的Hexo文件更新到GitHub仓库"></a>3.3 将本地的Hexo文件更新到GitHub仓库</h3><ul>
<li>进入刚刚新建的 GitHub 仓库</li>
<li>点击仓库页面右上角的 <code>Clone or download</code></li>
<li>复制弹出文本框中的地址或者点击文本框右侧的复制图标( <code>Use HTTPS</code> 或 <code>Use SSH</code> 均可)</li>
<li>在本地进入Hexo资源所在的目录找到根目录(划重点！是根目录，不是theme文件夹！)下的 <code>_config.yml</code> 文件，打开后找到末尾的 <code>deploy</code> 标签，修改成如下所示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: https://github.com/yiguohan/yiguohan.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：此处repository标签后填写的是你的 GitHub 仓库地址</p>
</blockquote>
<h2 id="4-生成静态网页和部署"><a href="#4-生成静态网页和部署" class="headerlink" title="4. 生成静态网页和部署"></a>4. 生成静态网页和部署</h2><ul>
<li>打开Terminal，使用cd命令进入Hexo资源所在的文件夹，输入以下命令生成静态网页：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo genrate</span><br></pre></td></tr></table></figure>
<ul>
<li>生成成功后，输入一下命令将生成好的网页部署到服务器上：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p><br>至此，博客已经基本搭建成功。如果你想了解更多关于 Hexo 静态博客的奇技淫巧，欢迎浏览 Hexo 的官方网站 </p>
<p><a href="https://hexo.io" target="_blank" rel="noopener">https://hexo.io</a></p>
<p>我(也许)也会在今后的博客中给大家带来相关的知识。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/30/写在前面/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="老易">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老易的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/30/写在前面/" itemprop="url">写在前面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-30T21:29:05+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;其实早在十一月初的时候就有在掘金上看到搭建博客的相关帖子了，一直想着来做。鉴于个人太忙(lan)一直拖到现在。</p>
<p>&emsp;&emsp;在去年找工作的这段时间中发现了一个还不错的学习方法——画思维导图。这种方法相当于把自己所学到的知识通过简单明了的关系图重新表达。这样可以避免走马观花式的学习——你以为你学到了，实际上转身就忘了。<br></p>
<p>&emsp;&emsp;但是，思维导图占用的面积很大，只能在特定的软件（如Xmind、MindManger）上显示。而且导出成常见的文件形式不是格式难看就是需要花费大价钱购买其会员，对于像我这么极(kou)客(men)范儿的人来说实在是没有那么友好，一直在寻找一种更好的办法来接替这种方法保存一些学习的笔记。</p>
<p>&emsp;&emsp;支持Markdown显示的Hexo静态网页很好的解决了这个问题。界面清爽不油腻，居家旅行必备。</p>
<p align="right">老易</p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">老易</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yiguohan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/yiguohan" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yiguohan" target="_blank" title="Facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/519920207" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">老易</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        




  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=65215428";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    







  





  

  

  

  
  

  

  

  

</body>
</html>
